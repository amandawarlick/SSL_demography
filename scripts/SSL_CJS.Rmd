

```{r setup, include = F}

knitr::opts_chunk$set(echo = FALSE, eval = FALSE, message = F, warning = F)

library(here) #v1.0.1
library(dplyr) #v1.0.5
library(nimble) #v0.12.1

source(here::here('scripts', 'PlotTheme.R'))


```

```{r params states}
# Parameters:
# phiP surv pup to yearling
# phi1 surv of yearling
# phi2 surv of 2 year old
# phi3 surv of 3 pre-breeder
# phi4 surv of 4 pre-breeder
# phi5 surv of 5 pre-breeder
# phiB surv of breeders 6+ years old
# phiN surv of NB breeders 5+ years old 
# phiPM surv pup to yearling male
# phi1M surv of yearling male
# phi2M surv of 2 male
# phi3M surv of 3 male
# phi4M surv of 4 male
# phi5M surv of 5 male
# phiBM surv of adult male
    
# psi3B = prob of 3 year old becoming 4 year old B
# psi4B = prob of 4 year old becoming 5 year old B
# psi5B = prob of 5 year old becoming 6 year old B 
# psiBB = prob of staying breeder given were a breeder
# psiNB = prob of becoming breeder given were a NB

# p1 = detection of yearling
# P2 = detection of 2
# p3 = detection of 3 
# p4 = detection of 4
# p5 = detection of 5
# pB = detection of B
# pNB = detection of NB 
# p1M = detection of yearling male
# P2M = detection of 2 male
# p3M = detection of 3 male
# p4M = detection of 4 male
# p5M = detection of 5 male
# pBM = detection of territorial males 6+
# delB = prob of correctly ascertaining presence of pup for breeders

# OBSERVATIONS
# 1 = pup w/o
# 2 = 1 w/o
# 3 = 2 w/o
# 4 = 3 w/o
# 5 = 4 w/o
# 6 = 4 w
# 7 = 5 w/o
# 8 = 5 w
# 9 = 6+ w/o
# 10 = 6+ w
# 11 = ND
# 1 = pup male
# 2 = 1yo male
# 3 = 2yo male
# 4 = 3 male
# 5 = 4 male
# 6 = 5 male
# 7 = 6+ male 
# 9 = ND male

# STATES
# females
# 1 = pup
# 2 = yearling
# 3 = age-2
# 4 = pre-breeding age-3
# 5 = pre-breeding age-4
# 6 = pre-breeding age-5
# 7 = age-4 w/ pup
# 8 = age-5 w/ pup
# 9 = age-6+ w/ pup
# 10 = age-5 non-breeder
# 11 = age-6+ non-breeder
# 12 = dead
# males
# 1 = pup
# 2 = yearling
# 3 = age-2
# 4 = age-3
# 5 = age-4
# 6 = age-5
# 7 = adult male
# 8 = dead

#4 yo natality: states 7/(5+7)
#5 yo natality: states 8/(8+6+10)
#6+ yo natality: states 9/(9+11)


```

```{r nimble functions}

#state transition - females
getPHI_f <- nimbleFunction(
  run = function(z=double(0), phiP=double(0), phi1=double(0), phi2=double(0), phi3=double(0), phi4=double(0),
                 phi5=double(0), phiB=double(0), phiNB=double(0),
                 psi3=double(0), psi4=double(0), psi5=double(0), psiB=double(0), psiNB=double(0)) {
   returnType(double(1))
   ans <- rep(0,12)
     if(z==1)   ans <- c(0,phiP,0,0,0,0,0,0,0,0,0,1-phiP) #pup
     if(z==2)   ans <- c(0,0,phi1,0,0,0,0,0,0,0,0,1-phi1)   #yearling   
     if(z==3)   ans <- c(0,0,0,phi2,0,0,0,0,0,0,0,1-phi2)  #2yr
     if(z==4)   ans <- c(0,0,0,0,phi3*(1-psi3),0,phi3*psi3,0,0,0,0,1-phi3)  #3yr to B/Pre-breeder
     if(z==5)   ans <- c(0,0,0,0,0,phi4*(1-psi4),0,phi4*psi4,0,0,0,1-phi4)    #4yr to B/Pre-breeder
     if(z==6)   ans <- c(0,0,0,0,0,0,0,0,phi5*psi5,0,phi5*(1-psi5),1-phi5)    #5yr to B/Non-breeder             
     if(z==7)   ans <- c(0,0,0,0,0,0,0,phi4*psiB,0,phi4*(1-psiB),0,1-phi4)  #4B to B/Non-breeder 
     if(z==8)   ans <- c(0,0,0,0,0,0,0,0,phi5*psiB,0,phi5*(1-psiB),1-phi5)       #5B to B/Non-breeder 
     if(z==9)   ans <- c(0,0,0,0,0,0,0,0,phiB*psiB,0,phiB*(1-psiB),1-phiB)       #6+B to B/Non-breeder 
     if(z==10)  ans <- c(0,0,0,0,0,0,0,0,phiNB*psiNB,0,phiNB*(1-psiNB),1-phiNB)   #5NB to B/Non-breeder 
     if(z==11)  ans <- c(0,0,0,0,0,0,0,0,phiNB*psiNB,0,phiNB*(1-psiNB),1-phiNB)      #6+NB to B/Non-breeder 
     if(z==12)  ans <- c(0,0,0,0,0,0,0,0,0,0,0,1) #D

   return(ans)
 }
)

#observations - females
getP_f <- nimbleFunction(
  run = function(z=double(0), p1=double(0), p2=double(0), p3=double(0), p4=double(0), p5=double(0),
                 pB=double(0), pNB=double(0), delB=double(0)) {
   returnType(double(1))
   ans <- rep(0,11)
     if(z==1)   ans <- c(1,0,0,0,0,0,0,0,0,0,0) #pups seen as pups
     if(z==2)   ans <- c(0,p1,0,0,0,0,0,0,0,0,1-p1)   #1yr      
     if(z==3)   ans <- c(0,0,p2,0,0,0,0,0,0,0,1-p2)   #2yr
     if(z==4)   ans <- c(0,0,0,p3,0,0,0,0,0,0,1-p3)   #3yr
     if(z==5)   ans <- c(0,0,0,0,p4,0,0,0,0,0,1-p4)    #4yr seen as Pre-breeder
     if(z==6)   ans <- c(0,0,0,0,0,0,p5,0,0,0,1-p5)    #5yr seen as PB          
     if(z==7)   ans <- c(0,0,0,0,pB*(1-delB),pB*delB,0,0,0,0,1-pB)    #4yr B seen as NB/B
     if(z==8)   ans <- c(0,0,0,0,0,0,pB*(1-delB),pB*delB,0,0,1-pB)    #5yr B seen as NB/B
     if(z==9)   ans <- c(0,0,0,0,0,0,0,0,pB*(1-delB),pB*delB,1-pB)    #6+ B seen as NB/B
     if(z==10)  ans <- c(0,0,0,0,0,0,pNB,0,0,0,1-pNB) #5+ NB seen as Non-breeder
     if(z==11)  ans <- c(0,0,0,0,0,0,0,0,pNB,0,1-pNB) #6+ NB seen as NB
     if(z==12)  ans <- c(0,0,0,0,0,0,0,0,0,0,1)

   return(ans)
 }
)

#state transition - males
getPHI_m <- nimbleFunction(
  run = function(z=double(0), phiPM=double(0), phi1M=double(0), phi2M=double(0), phi3M=double(0), phi4M=double(0),
                 phi5M=double(0), phiBM=double(0)) {
   returnType(double(1))
   ans <- rep(0,8)
     if(z==1)   ans <- c(0,phiPM,0,0,0,0,0,1-phiPM) #pup
     if(z==2)   ans <- c(0,0,phi1M,0,0,0,0,1-phi1M) #yearling
     if(z==3)   ans <- c(0,0,0,phi2M,0,0,0,1-phi2M) #2yr
     if(z==4)   ans <- c(0,0,0,0,phi3M,0,0,1-phi3M) #3yr 
     if(z==5)   ans <- c(0,0,0,0,0,phi4M,0,1-phi4M) #4yr 
     if(z==6)   ans <- c(0,0,0,0,0,0,phi5M,1-phi5M) #5yr              
     if(z==7)   ans <- c(0,0,0,0,0,0,phiBM,1-phiBM) #adult
     if(z==8)   ans <- c(0,0,0,0,0,0,0,1) #D
     
   return(ans)
 }
)

#observations - males
getP_m <- nimbleFunction(
  run = function(z=double(0), p1M=double(0), p2M=double(0), p3M=double(0), p4M=double(0), p5M=double(0),
                 pBM=double(0)) {
   returnType(double(1))
   ans <- rep(0,8)
     if(z==1)   ans <- c(1,0,0,0,0,0,0,0)       #pup
     if(z==2)   ans <- c(0,p1M,0,0,0,0,0,1-p1M) #yearling    
     if(z==3)   ans <- c(0,0,p2M,0,0,0,0,1-p2M) #2yr
     if(z==4)   ans <- c(0,0,0,p3M,0,0,0,1-p3M) #3
     if(z==5)   ans <- c(0,0,0,0,p4M,0,0,1-p4M) #4 
     if(z==6)   ans <- c(0,0,0,0,0,p5M,0,1-p5M) #5               
     if(z==7)   ans <- c(0,0,0,0,0,0,pBM,1-pBM) #adult
     if(z==8)   ans <- c(0,0,0,0,0,0,0,1)   #D
   return(ans)
 }
)

```


##### models for individuals branded in the eastern portion of the range

```{r load data eastern portion of the range, echo = F, eval = T}

## capture histories
ch_fem <- read.csv(here::here('data', 'ProcData','ch_fem_EAST.csv'),
                   header = T, stringsAsFactors = F) %>%
  transform(Sex = ifelse(Sex == 'FALSE', 'F', NA)) 
ch_male <- read.csv(here::here('data', 'ProcData', 'ch_m_EAST.csv'),
                    header = T, stringsAsFactors = F)

#number of times females seen per year
resights <- read.csv(here::here('data', 'ProcData', 'num_resight_EAST.csv'),
                     header = T, stringsAsFactors = F)

## variables and dimensions
n_occasions <- dim(ch_fem)[2]-7 #subtract id columns
res_mat <- as.matrix(resights[,2:dim(resights)[2]]) #1: 1-2 resights, 2: 3-8, 3: 9+, 4: ND

## rough estimate of effort
eff <- c(rep(1, 18))[1:18]
eff[c(6,17,18)] <- 2 #less effort in 2006, 2017-2018 (no field camps)

mass_f <- ch_fem$Mass_std
mass_m <- ch_male$Mass_std

```

```{r fc inits}

##female
#first capture
get.first <- function(x) min(which(x == 1)) #pups only
fc <- apply(ch_fem[,-c(1:7)], 1, get.first)

ch <- ch_fem[,-c(1:7)]
for (i in 1:dim(ch)[1]) {
  if(fc[i] > 1) {ch[i, 1:(fc[i]-1)] <- NA }
}

y <- as.matrix(ch)

# Initial values for possible states
# "NA" for the latent state at all places before an individual was observed, 
# if t > fc & t <= fc + 3, then init = t-fc
# if t = fc + 4, then ind is 4yr, init = either 5 or 7
# if t = fc + 5, then ind is 5yr, init = either 6, 8, 10
# if t >= fc + 6, then ind is 6yr, init = either 9 or 10

cjs.me.init <- function(ch, fc){
  inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
  for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){   
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 7} #all 4yrs are (pre-)breeders
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 8} #all 5yrs are breeders
      if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 9} #all 6yrs+ are breeders
  } #i
  return(inits)
}

z.init = as.matrix(cjs.me.init(ch, fc))
#if giving latent z.st as data, change z.init in these ways:
z.init[which(y < 5)] <- NA #all obs pre-breeders are known state, so don't estimate
z.init[which(y == 6)] <- NA  #all obs w pup are known state, don't estimate
z.init[which(y == 8)] <- NA
z.init[which(y == 10)] <- NA

#want NAs where we're estimating, except state == 1 since that is set in the model
z.st <- as.matrix(ch)
z.st[which(z.st == 1)] <- NA
z.st[which(z.st == 11)] <- NA #all ND are unknown state
z.st[which(z.st == 5)] <- NA  #all obs w/o pup are unknown state, otherwise state can be obs equivalent
z.st[which(z.st == 7)] <- NA
z.st[which(z.st == 9)] <- NA
z.st[which(z.st == 6)] <- 7 #obs of 6 is state 7
z.st[which(z.st == 10)] <- 9 #obs of 10 is state 9; obs of 8 is state 8 leave as is

get.first.m <- function(x) min(which(x != 8)) #include animals branded as non-pups
fc_m <- apply(ch_male[,-c(1:7)], 1, get.first.m)

ch_m <- ch_male[,-c(1:7)]
for (i in 1:dim(ch_m)[1]) {
  if(fc_m[i] > 1) {ch_m[i, 1:(fc_m[i]-1)] <- NA } #everything NA before first capture
}

ym <- as.matrix(ch_m)

cjs.me.init.m <- function(ch, fc) {
    inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
    for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){    
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 5} #4 yr old
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 6} #5 yr olds
     if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 7} #start all adult age animals at 7
  } #i
  return(inits)
}

z.init.m = as.matrix(cjs.me.init.m(ch_m, fc_m))
#if giving latent z.st as data, change z.init in these ways:
z.init.m[which(ym == 1)] <- NA
z.init.m[which(ym == 2)] <- NA
z.init.m[which(ym == 3)] <- NA
z.init.m[which(ym == 4)] <- NA
z.init.m[which(ym == 5)] <- NA
z.init.m[which(ym == 6)] <- NA
z.init.m[which(ym == 7)] <- NA

#known latent state
z.st.m <- as.matrix(ch_m)

get.first.B <- function(x) min(which(x == 7))
fb <- apply(ch_male[,-c(1:7)], 1, get.first.B) #inf warnings for animals never seen as an adult
get.last.B <- function(x) max(which(x == 7)) 
lb <- apply(ch_male[,-c(1:7)], 1, get.last.B)

#want NAs where we're estimating, except state == 1 since that is set in the model
z.st.m[which(z.st.m == 1)] <- NA
z.st.m[which(z.st.m == 8)] <- NA #not detected

#breeder between breeding observations
for (i in 1:dim(z.st.m)[1]) {
  if (fb[i] != Inf) {
    z.st.m[i, (fb[i]:lb[i])] <- 7
  }
}

z.init.m[which(z.st.m == 7)] <- NA #need to get the between-breeder observations for inits too, not just all == 7

## recapture summary stats
#i=1 lots of resights
#i=6 single resight
#i=2 no resights
# capt <- numeric()
# for (i in 1:dim(ch)[1]) {
#   capt[i] <- as.numeric(sum(ch[i,(fc[i]+1):n_occasions]<11)<1) #will be TRUE for inds never recapt
# }
# 
# #capt==1 for inds never resighted; 553/1322 == 41%
# sum(capt>0)/length(capt)
# 
# capt_m <- numeric()
# for (i in 1:dim(ch_m)[1]) {
#   capt_m[i] <- as.numeric(sum(ch_m[i,(fc_m[i]+1):n_occasions]<8)<1) #will be TRUE for inds never recapt
# }
# 
# #capt==1 for inds never resighted; 622/1330 == 47%
# sum(capt_m>0)/length(capt_m)
# 
# ## distribution of resights for females
# res_actual <- read.csv(here::here('SSL_CJS', 'Data', 'resights_actual.csv'), 
#                        header = T, stringsAsFactors = F)
# res_actual <- res_actual[,2:(n_occasions+1)]
# 
# capt_freq <- capt_sd <- numeric()
# for (i in 1:dim(res_actual)[1]) { 
# 
#   cols <- which(res_actual[i,]!=0)
#   capt_freq[i] <- mean(as.numeric(res_actual[i,cols[which(cols>fc[i])]])) #average per ind across yrs
#   capt_sd[i] <- sd(as.numeric(res_actual[i,cols[which(cols>fc[i])]])) #variability across yrs
# }

#individuals recaptured an average of 6 times per year
# capt_freq_avg <- mean(capt_freq, na.rm = T)
# #variability in recaptures across individuals: 7.1
# capt_sd_avg <- sd(capt_freq, na.rm = T) 

```

```{r ocean covariates}

#adjusted year is the survival period (adj year == 1 is pups born in 2000 surviving to 2001)
#fall and summer adj_year 0 == NA (would be Sept-Dec 1999)
#spring and winter adj_year 18 == NA (would be Jan-May 2018, for pups born in 2017)

ocean_SSL <- read.csv(here::here('data', 'ProcData', 'ocean_all_adj_east.csv'), 
                      stringsAsFactors = F, header = T) %>%
  filter(adj_year > 0 & adj_year < 19) 

#adj_year 1 = survival from 2000 to 2001; 18 = survival from 2017 to 2018
start <- 1; stop <- 18
seas <- 'NB' #spans entire non-breeding season
# seas <- 'spr'
# seas <- 'sum'
# seas <- 'fall'
# seas <- 'win'

albsa <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$ALBSA_', seas, '[', start,':', stop,']')))))
PDO <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$PDO_', seas, '[', start,':', stop,']')))))
AOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$AOI_', seas, '[', start,':', stop,']')))))
upwell <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$upwell_', seas, '[', start,':', stop,']')))))
chla <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$chla_', seas, '[', start,':', stop,']')))))
sst <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$sst_', seas, '[', start,':', stop,']')))))
vwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$vwnd_', seas, '[', start,':', stop,']')))))
uwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$uwnd_', seas, '[', start,':', stop,']')))))
NOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$NOI_', seas, '[', start,':', stop,']')))))
prod <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$prod_', seas, '[', start,':', stop,']')))))
scal <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$scalar_', seas, '[', start,':', stop,']')))))
npgo <- eval(parse(text = paste0('ocean_SSL$NPGO_', seas, '[', start,':', stop,']')))

# fix NA values
albsa[is.na(albsa)] <- 0
PDO[is.na(PDO)] <- 0
AOI[is.na(AOI)] <- 0
upwell[is.na(upwell)] <- 0
npgo[is.na(npgo)] <- 0
chla[is.na(chla)] <- 0
sst[is.na(sst)] <- 0
vwnd[is.na(vwnd)] <- 0
uwnd[is.na(uwnd)] <- 0
prod[is.na(prod)] <- 0
NOI[is.na(NOI)] <- 0
scal[is.na(scal)] <- 0

## To examine correlations
library(Hmisc)
library(corrplot)
## single season - all variables
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)
  data.frame(
    row = rownames(cormat)[row(cormat)[ut]],
    column = rownames(cormat)[col(cormat)[ut]],
    cor  =(cormat)[ut],
    p = pmat[ut]
  )
}
cor <- rcorr(as.matrix(ocean_SSL[,grepl('sum', colnames(ocean_SSL))]))
cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
         insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)

#strongly correlated variables
#NB: PDO-MEI/NOI/NPI, albsa-NPI
# spring: PDO-NOI/NPI/SST, albsa-curl, NPI-up, sst-MEI
#summer: MEI-PDO/NPGO, albsa-NPI, AOI-NPI, MEI-NOI
#fall: NOI-PDO, PDO-MEI, NOI-MEI, AOI-albsa
#winter: NPI-albsa, MEI-albsa, MEI-PDO, uwnd-PDO, curl-albsa, curl-chla


```

```{r null model text}

SSL_CJS <- nimbleCode({

# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.P 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 + b.eff[eff[t]] 
        } #t 
  
  for (t in 2:(n_occasions-1)) {
    logit(phi1[i,t]) <- mu.1  
    logit(p2[i,t]) <- mean.p2 + b.eff[eff[t]] 
  }
  
  for (t in 3:(n_occasions-1)) {
    logit(phi2[i,t]) <- mu.2 
    logit(p3[i,t]) <- mean.p3 + b.eff[eff[t]] 
  }
  
  #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
      for (t in 4:(n_occasions-1)) { 
      logit(psi3[i,t]) <- mean.psi3 
      logit(phi3[i,t]) <- mu.3 + epsPB[t]
      logit(p4[i,t]) <- mean.p4 + b.eff[eff[t]] 
      logit(pB[i,t]) <- mean.pB + b.eff[eff[t]] 
    } #t psi
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      logit(psi4[i,t]) <- mean.psi4 
      logit(psiB[i,t]) <- mean.psiB 
      logit(phi4[i,t]) <- mu.4 
      logit(phiB[i,t]) <- mu.B 
      logit(p5[i,t]) <- mean.p5 + b.eff[eff[t]]
      logit(pNB[i,t]) <- mean.pNB + b.eff[eff[t]] 
    } #t psi
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {  
      logit(psi5[i,t]) <- mean.psi5 
      logit(psiNB[i,t]) <- mean.psiNB 
      logit(phi5[i,t]) <- mu.5 
      logit(phiNB[i,t]) <- mu.NB 
          } #t psi
} #i fem
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
    }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions-1)) {
            logit(phiPM[i,t]) <- mu.PM 
            logit(p1M[i,t]) <- mean.p1M + b.eff[eff[t]] 
        } #t
    
    for (t in 2:(n_occasions-1)) {
            logit(phi1M[i,t]) <- mu.1M 
            logit(p2M[i,t]) <- mean.p2M + b.eff[eff[t]] 
          }
    for (t in 3:(n_occasions-1)) {
            logit(phi2M[i,t]) <- mu.2M 
            logit(p3M[i,t]) <- mean.p3M + b.eff[eff[t]] 
    }
    for (t in 4:(n_occasions-1)) {
            logit(phi3M[i,t]) <- mu.3M 
            logit(p4M[i,t]) <- mean.p4M + b.eff[eff[t]] 
    }
    for (t in 5:(n_occasions-1)) {
            logit(phi4M[i,t]) <- mu.4M 
            logit(p5M[i,t]) <- mean.p5M + b.eff[eff[t]] 
    }
    for (t in 6:(n_occasions-1)) {
            logit(phi5M[i,t]) <- mu.5M 
            logit(pBM[i,t]) <- mean.pBM + b.eff[eff[t]] 
    }
    for (t in 7:(n_occasions-1)) {
            logit(phiBM[i,t]) <- mu.BM  
    }
} #i male
  
### Priors
    #psi
    mean.psi3 <- log(int.psi3/(1-int.psi3))
    mean.psi4 <- log(int.psi4/(1-int.psi4))
    mean.psi5 <- log(int.psi5/(1-int.psi5))
    mean.psiB <- log(int.psiB/(1-int.psiB))
    mean.psiNB <- log(int.psiNB/(1-int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    #p
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pB <- log(int.pB/(1 - int.pB))
    mean.pNB <- log(int.pNB/(1 - int.pNB))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pBM <- log(int.pBM/(1 - int.pBM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pB ~ dunif(0,1)
    int.pNB ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pBM ~ dunif(0,1)
    #phi
    mu.P <- log(int.phiP/(1 - int.phiP))
    mu.1 <- log(int.phi1/(1 - int.phi1))
    mu.2 <- log(int.phi2/(1 - int.phi2))
    mu.3 <- log(int.phi3/(1 - int.phi3))
    mu.4 <- log(int.phi4/(1 - int.phi4))
    mu.5 <- log(int.phi5/(1 - int.phi5))
    mu.B <- log(int.phiB/(1 - int.phiB))
    mu.NB <- log(int.phiNB/(1 - int.phiNB))
    mu.PM <- log(int.phiPM/(1 - int.phiPM))
    mu.1M <- log(int.phi1M/(1 - int.phi1M))
    mu.2M <- log(int.phi2M/(1 - int.phi2M))
    mu.3M <- log(int.phi3M/(1 - int.phi3M))
    mu.4M <- log(int.phi4M/(1 - int.phi4M))
    mu.5M <- log(int.phi5M/(1 - int.phi5M))
    mu.BM <- log(int.phiBM/(1 - int.phiBM))
    int.phiP ~ dunif(0,1)
    int.phi1 ~ dunif(0,1)
    int.phi2 ~ dunif(0,1)
    int.phi3 ~ dunif(0,1)
    int.phi4 ~ dunif(0,1)
    int.phi5 ~ dunif(0,1)
    int.phiB ~ dunif(0,1)
    int.phiNB ~ dunif(0,1)
    int.phiPM ~ dunif(0,1)
    int.phi1M ~ dunif(0,1)
    int.phi2M ~ dunif(0,1)
    int.phi3M ~ dunif(0,1)
    int.phi4M ~ dunif(0,1)
    int.phi5M ~ dunif(0,1)
    int.phiBM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -5 #0 on probability scale

    b.eff[1] <- 0
    b.eff[2] ~ dnorm(0, 0.001)
    
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    } #t likelihood fem
} #i likelihood fem
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i, t, 1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1], pBM = pBM[i,t-1])
    } # likelihood t male
   } #likelihood i male
    
}) # mod   

##### run model ####
nim.data <- list(y = y, ym = ym, 
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], 
                      n_occasions = n_occasions,
                      resights = res_mat,
                      eff = eff, mass_f = mass_f, mass_m = mass_m,
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiP = 0.9, int.phiPM = 0.9, int.phi1 = 0.9, int.phi1M = 0.9,
              int.phi2 = 0.9, int.phi2M = 0.9, int.phi3 = 0.9, int.phi3M = 0.9,
              int.phi4 = 0.9, int.phi4M = 0.9, int.phi5 = 0.9, int.phi5M = 0.75,
              int.phiB = 0.9, int.phiBM = 0.8, int.phiNB = 0.9, 
              mean.psi3 = qlogis(0.25), mean.psi4 = qlogis(0.6), mean.psi5 = qlogis(0.25),
              mean.psiB = qlogis(0.9), mean.psiNBM = 0.2, #prob scale for these
              mean.p1 = qlogis(0.7), mean.p2 = qlogis(0.6),
              mean.p3 = qlogis(0.6),mean.p4 = qlogis(0.6),
              mean.p5 = qlogis(0.4), mean.pB = 0.8, mean.pNB = qlogis(0.4),
              mean.p1M = qlogis(0.5), mean.p2M = qlogis(0.5), mean.p3M = qlogis(0.5), 
              mean.p4M = qlogis(0.5), 
              mean.pBM = qlogis(0.8), mean.p5M = qlogis(0.6),
              p.delB = c(0.4, 0.5, 0.75), 
              z = z.init, zm = z.init.m)

### parameters
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pB', 'mean.pNB',
            'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pBM', 
            "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB',
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pB', 'int.pNB', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pBM',  
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB',
            'int.phiP', 'int.phi1', 'int.phi2', 'int.phi3', 'int.phi4', 'int.phi5', 
            'int.phiB', 'int.phiNB',
            'int.phiPM', 'int.phi1M', 'int.phi2M', 'int.phi3M', 'int.phi4M', 'int.phi5M', 'int.phiBM',
            'nat_all', 'nat4', 'nat5', 'nat6plus',
            'b.delB', 'p.delB', 
            'b.eff', 
            'z', 'zm', 
            'mu.P', 'mu.1', 'mu.2', 'mu.3', 'mu.4', 'mu.5', 'mu.B', 'mu.NB', 
            'mu.PM', 'mu.1M', 'mu.2M', 'mu.3M', 'mu.4M', 'mu.5M', 'mu.BM')

### run model
n.iter = 35000; n.chains = 3; n.burnin = 20000; nthin = 3; nAdapt = 20

start <- Sys.time()

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE, enableWAIC = TRUE)


Rmcmc <- buildMCMC(conf)  #produce uncompiled R mcmc function
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)



```

```{r random effects model text}

#random effects for survival, breeding probability, and detection plus pup mass covariate
#correlated random effects across several age/sex-based groups

SSL_CJS <- nimbleCode({

# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.P + epsP[t] + b.mass.p*mass_f[i] 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 + b.eff[eff[t]] + eps.p[t] 
        } #t 
  
  for (t in 2:(n_occasions-1)) {
    logit(phi1[i,t]) <- mu.1 + eps1[t] +
              b.mass.1*mass_f[i] 
    logit(p2[i,t]) <- mean.p2 + b.eff[eff[t]] + eps.p[t]
  }
  
  for (t in 3:(n_occasions-1)) {
    logit(phi2[i,t]) <- mu.2 + eps2[t] +
              b.mass.1*mass_f[i] 
    logit(p3[i,t]) <- mean.p3 + b.eff[eff[t]] + eps.p[t]
  }
  
  #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
      for (t in 4:(n_occasions-1)) { 
      logit(psi3[i,t]) <- mean.psi3 + eps.psiPB[t] +
             b.mass.psi*mass_f[i]
      logit(phi3[i,t]) <- mu.3 + epsPB[t]
      logit(p4[i,t]) <- mean.p4 + b.eff[eff[t]] + eps.p[t]
      logit(pB[i,t]) <- mean.pB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      logit(psi4[i,t]) <- mean.psi4 + eps.psiPB[t] +
              b.mass.psi*mass_f[i]
      logit(psiB[i,t]) <- mean.psiB + eps.psiB[t] +
              b.mass.psiB*mass_f[i]
      logit(phi4[i,t]) <- mu.4 + epsPB[t]
      logit(phiB[i,t]) <- mu.B + epsB[t]
      logit(p5[i,t]) <- mean.p5 + b.eff[eff[t]] + eps.p[t]
      logit(pNB[i,t]) <- mean.pNB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {  
      logit(psi5[i,t]) <- mean.psi5 + eps.psiPB[t] +
              b.mass.psi*mass_f[i]
      logit(psiNB[i,t]) <- mean.psiNB + eps.psiNB[t] +
              b.mass.psiB*mass_f[i]
      logit(phi5[i,t]) <- mu.5 + epsPB[t]
      logit(phiNB[i,t]) <- mu.NB + epsNB[t]
          } #t psi
} #i fem
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
    }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.PM + epsP[t] +
              b.mass.pm*mass_m[i] 
            logit(p1M[i,t]) <- mean.p1M + b.eff[eff[t]] + eps.p[t] 
        } #t
    
    for (t in 2:(n_occasions-1)) {
            logit(phi1M[i,t]) <- mu.1M + eps1[t] +
              b.mass.1m*mass_m[i] 
            logit(p2M[i,t]) <- mean.p2M + b.eff[eff[t]] + eps.p[t]
          }
    for (t in 3:(n_occasions-1)) {
            logit(phi2M[i,t]) <- mu.2M + eps2[t] +
              b.mass.1m*mass_m[i] 
            logit(p3M[i,t]) <- mean.p3M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 4:(n_occasions-1)) {
            logit(phi3M[i,t]) <- mu.3M + epsPB[t] 
            logit(p4M[i,t]) <- mean.p4M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 5:(n_occasions-1)) {
            logit(phi4M[i,t]) <- mu.4M + epsPB[t] 
            logit(p5M[i,t]) <- mean.p5M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 6:(n_occasions-1)) {
            logit(phi5M[i,t]) <- mu.5M + epsPB[t] 
            logit(pBM[i,t]) <- mean.pBM + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 7:(n_occasions-1)) {
            logit(phiBM[i,t]) <- mu.BM + epsBM[t] 
    }
} #i male
  
### Priors
    mean.psi3 <- log(int.psi3/(1-int.psi3))
    mean.psi4 <- log(int.psi4/(1-int.psi4))
    mean.psi5 <- log(int.psi5/(1-int.psi5))
    mean.psiB <- log(int.psiB/(1-int.psiB))
    mean.psiNB <- log(int.psiNB/(1-int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pB <- log(int.pB/(1 - int.pB))
    mean.pNB <- log(int.pNB/(1 - int.pNB))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pBM <- log(int.pBM/(1 - int.pBM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pB ~ dunif(0,1)
    int.pNB ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pBM ~ dunif(0,1)
    mu.P <- log(int.phiP/(1 - int.phiP))
    mu.1 <- log(int.phi1/(1 - int.phi1))
    mu.2 <- log(int.phi2/(1 - int.phi2))
    mu.3 <- log(int.phi3/(1 - int.phi3))
    mu.4 <- log(int.phi4/(1 - int.phi4))
    mu.5 <- log(int.phi5/(1 - int.phi5))
    mu.B <- log(int.phiB/(1 - int.phiB))
    mu.NB <- log(int.phiNB/(1 - int.phiNB))
    mu.PM <- log(int.phiPM/(1 - int.phiPM))
    mu.1M <- log(int.phi1M/(1 - int.phi1M))
    mu.2M <- log(int.phi2M/(1 - int.phi2M))
    mu.3M <- log(int.phi3M/(1 - int.phi3M))
    mu.4M <- log(int.phi4M/(1 - int.phi4M))
    mu.5M <- log(int.phi5M/(1 - int.phi5M))
    mu.BM <- log(int.phiBM/(1 - int.phiBM))
    int.phiP ~ dunif(0,1)
    int.phi1 ~ dunif(0,1)
    int.phi2 ~ dunif(0,1)
    int.phi3 ~ dunif(0,1)
    int.phi4 ~ dunif(0,1)
    int.phi5 ~ dunif(0,1)
    int.phiB ~ dunif(0,1)
    int.phiNB ~ dunif(0,1)
    int.phiPM ~ dunif(0,1)
    int.phi1M ~ dunif(0,1)
    int.phi2M ~ dunif(0,1)
    int.phi3M ~ dunif(0,1)
    int.phi4M ~ dunif(0,1)
    int.phi5M ~ dunif(0,1)
    int.phiBM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -5 #0 on probability scale

    b.eff[1] <- 0
    b.eff[2] ~ dnorm(0, 0.001)
    
    for (t in 1:(n_occasions)) {
      eps.p[t] ~ dnorm(0, sd = sigma.p)
    }

    sigma.p ~ dexp(1)
    
    for (t in 1:(n_occasions-1)){
      epsP[t] ~ dnorm(0, sd = sigmaP)
    } 

    for (t in 2:(n_occasions-1)) {
      eps1[t] ~ dnorm(0, sd = sigma1)
    }
    
    for (t in 3:(n_occasions-1)) {
      eps2[t] ~ dnorm(0, sd = sigma2)
    }
    #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
    for (t in 4:(n_occasions-1)) { 
      eps.psiPB[t] ~ dnorm(0, sd = sigma.psiPB)
      epsPB[t] ~ dnorm(0, sd = sigmaPB)
    } #t
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      eps.psiB[t] ~ dnorm(0, sd = sigma.psiB)
      epsB[t] ~ dnorm(0, sd = sigmaB)
      epsBM[t] ~ dnorm(0, sd = sigmaB)
    } #t
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {
    eps.psiNB[t] ~ dnorm(0, sd = sigma.psiNB)
    epsNB[t] ~ dnorm(0, sd = sigmaNB)
    } #t

  #shrinkage priors
    sigmaP ~ dexp(1)
    sigma1 ~ dexp(1)
    sigma2 ~ dexp(1)
    sigmaPB ~ dexp(1)
    sigmaB ~ dexp(1)
    sigmaNB ~ dexp(1)
    sigma.psiPB ~ dexp(1)
    sigma.psiB ~ dexp(1)
    sigma.psiNB ~ dexp(1)
    
    #covs - psi 
    b.mass.psi ~ dnorm(0, sd = s.mass.psi)
    s.mass.psi ~ dexp(1)
    b.mass.psiB ~ dnorm(0, sd = s.mass.psiB)
    s.mass.psiB ~ dexp(1)

    #covs - phi
    b.mass.p ~ dnorm(0, sd = s.mass.p)
    s.mass.p ~ dexp(1)
    b.mass.pm ~ dnorm(0, sd = s.mass.pm)
    s.mass.pm ~ dexp(1)
    
    b.mass.1 ~ dnorm(0, sd = s.mass.1)
    s.mass.1 ~ dexp(1)
    b.mass.1m ~ dnorm(0, sd = s.mass.1m)
    s.mass.1m ~ dexp(1)
  
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    } #t likelihood fem
} #i likelihood fem
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1], pBM = pBM[i,t-1])
    } # likelihood t male
   } #likelihood i male
    
}) # mod   

##### run model ####

nim.data <- list(y = y, ym = ym, 
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], 
                      n_occasions = n_occasions, resights = res_mat, eff = eff,
                      mass_f = mass_f, mass_m = mass_m,
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiP = 0.9, int.phiPM = 0.9, int.phi1 = 0.9, int.phi1M = 0.9,
              int.phi2 = 0.9, int.phi2M = 0.9, int.phi3 = 0.9, int.phi3M = 0.9,
              int.phi4 = 0.9, int.phi4M = 0.9, int.phi5 = 0.9, int.phi5M = 0.75,
              int.phiB = 0.9, int.phiBM = 0.8, int.phiNB = 0.9, 
              mean.psi3 = qlogis(0.25), mean.psi4 = qlogis(0.6), mean.psi5 = qlogis(0.25),
              mean.psiB = qlogis(0.9), mean.psiNBM = 0.2, 
              mean.p1 = qlogis(0.7), mean.p2 = qlogis(0.6),
              mean.p3 = qlogis(0.6),mean.p4 = qlogis(0.6),
              mean.p5 = qlogis(0.4), mean.pB = 0.8, mean.pNB = qlogis(0.4),
              mean.p1M = qlogis(0.5), mean.p2M = qlogis(0.5), mean.p3M = qlogis(0.5), 
              mean.p4M = qlogis(0.5), 
              mean.pBM = qlogis(0.8), mean.p5M = qlogis(0.6),
              eps.p = c(rep(0, n_occasions)), 
              epsP = rep(0, n_occasions-1), eps1 = rep(0, n_occasions-1), eps2 = rep(0, n_occasions-1),
              epsPB = rep(0, n_occasions-1), epsB = rep(0, n_occasions-1), 
              epsNB = rep(0, n_occasions-1), epsBM = rep(0, n_occasions-1),
              eps.psiPB = rep(0, n_occasions-1), 
              eps.psiB = rep(0, n_occasions-1), eps.psiNB = rep(0, n_occasions-1),
              sigmaPB = 1, sigmaP = 1, sigmaB = 1, sigma2 = 1, sigma1 = 1, sigma.psi = 1,
              p.delB = c(0.4, 0.5, 0.75), 
              b.mass.p = 0, b.mass.pm = 0, b.mass.psi = 0, b.mass.psiB = 0,
              b.mass.1 = 0, b.mass.1m = 0, 
              z = z.init, zm = z.init.m)

### parameters
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pB', 'mean.pNB',
            'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pBM', 
            "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB',
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pB', 'int.pNB', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pBM',  
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB',
            'int.phiP', 'int.phi1', 'int.phi2', 'int.phi3', 'int.phi4', 'int.phi5', 'int.phiB', 'int.phiNB',
            'int.phiPM', 'int.phi1M', 'int.phi2M', 'int.phi3M', 'int.phi4M', 'int.phi5M', 'int.phiBM',
            'epsP', 'eps1', 'eps2','epsPB','epsB', 'epsNB', 'epsBM',
            'eps.psiPB', 'eps.psiB', 'eps.psiNB',
            'b.delB', 'p.delB','b.eff', 'eps.p', 
             'sigmaP', 'sigma1', 'sigma2', 'sigmaPB', 'sigmaB', 'sigmaNB',
            'sigma.psiPB', 'sigma.psiB', 'sigma.psiNB','sigma.p', 
            'b.mass.p', 'b.mass.1', 'b.mass.pm', 'b.mass.1m', 'b.mass.psi', 'b.mass.psiB',
            'z', 'zm', 'mu.P', 'mu.1', 'mu.2', 'mu.3', 'mu.4', 'mu.5', 'mu.B', 'mu.NB', 
            'mu.PM', 'mu.1M', 'mu.2M', 'mu.3M', 'mu.4M', 'mu.5M', 'mu.BM')

### run model
n.iter = 35000; n.chains = 3; n.burnin = 20000; nthin = 3; nAdapt = 20

start <- Sys.time()

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)


Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)

```

```{r full model text}

#notes
#psi.... state in t is product of survival and breeding probability in t-1, 
#for a 3yo that survived and transitioned to become a 4yo w/ pup, the conditions in t-1 or throughout the year (yr starts w/ summer) mattered for success
# if 3yo in 2005 summer, breed to become 4yo w/ pup in 2006, then summer in 2005 would matter more than 2006
#summer months are 6:9

SSL_CJS <- nimbleCode({

# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.P + epsP[t] +
              b.albsaP*albsa[t] +
              b.AOIP*AOI[t] +
              b.upP*upwell[t] +
              b.chlaP*chla[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              b.massP*mass_f[i] 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 + b.eff[eff[t]] + eps.p[t] 
        } #t 
  
  for (t in 2:(n_occasions-1)) {
    logit(phi1[i,t]) <- mu.1 + eps1[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1*mass_f[i] 
    logit(p2[i,t]) <- mean.p2 + b.eff[eff[t]] + eps.p[t]
  }
  
  for (t in 3:(n_occasions-1)) {
    logit(phi2[i,t]) <- mu.2 + eps2[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1*mass_f[i] 
    logit(p3[i,t]) <- mean.p3 + b.eff[eff[t]] + eps.p[t]
  }
  
  #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
      for (t in 4:(n_occasions-1)) { 
      logit(psi3[i,t]) <- mean.psi3 + eps.psiPB[t] +
              b.albsa.psi*albsa[t] +
              b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] +
              b.chla.psi*chla[t] +
              b.vwnd.psi*vwnd[t] +
              b.npgo.psi*npgo[t] +
              b.mass.psi*mass_f[i]
      logit(phi3[i,t]) <- mu.3 + epsPB[t]
      logit(p4[i,t]) <- mean.p4 + b.eff[eff[t]] + eps.p[t]
      logit(pB[i,t]) <- mean.pB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      logit(psi4[i,t]) <- mean.psi4 + eps.psiPB[t] +
              b.albsa.psi*albsa[t] +
              b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] +
              b.chla.psi*chla[t] +
              b.vwnd.psi*vwnd[t] +
              b.npgo.psi*npgo[t] +
              b.mass.psi*mass_f[i]
      logit(psiB[i,t]) <- mean.psiB + eps.psiB[t] +
              b.albsa.psiB*albsa[t] +
              b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] +
              b.chla.psiB*chla[t] +
              b.vwnd.psiB*vwnd[t] +
              b.npgo.psiB*npgo[t] +
              b.mass.psiB*mass_f[i]
      logit(phi4[i,t]) <- mu.4 + epsPB[t]
      logit(phiB[i,t]) <- mu.B + epsB[t]
      logit(p5[i,t]) <- mean.p5 + b.eff[eff[t]] + eps.p[t]
      logit(pNB[i,t]) <- mean.pNB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {  
      logit(psi5[i,t]) <- mean.psi5 + eps.psiPB[t] +
              b.albsa.psi*albsa[t] +
              b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] +
              b.chla.psi*chla[t] +
              b.vwnd.psi*vwnd[t] +
              b.npgo.psi*npgo[t] +
              b.mass.psi*mass_f[i]
      logit(psiNB[i,t]) <- mean.psiNB + eps.psiNB[t] +
              b.albsa.psiB*albsa[t] +
              b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] +
              b.chla.psiB*chla[t] +
              b.vwnd.psiB*vwnd[t] +
              b.npgo.psiB*npgo[t] +
              b.mass.psiB*mass_f[i]
      logit(phi5[i,t]) <- mu.5 + epsPB[t]
      logit(phiNB[i,t]) <- mu.NB + epsNB[t]
          } #t psi
} #i fem
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
    }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.PM + epsP[t] +
              b.albsaP*albsa[t] +
              b.AOIP*AOI[t] +
              b.upP*upwell[t] +
              b.chlaP*chla[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              b.massPM*mass_m[i] 
            logit(p1M[i,t]) <- mean.p1M + b.eff[eff[t]] + eps.p[t] 
        } #t
    
    for (t in 2:(n_occasions-1)) {
            logit(phi1M[i,t]) <- mu.1M + eps1[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1M*mass_m[i] 
            logit(p2M[i,t]) <- mean.p2M + b.eff[eff[t]] + eps.p[t]
          }
    for (t in 3:(n_occasions-1)) {
            logit(phi2M[i,t]) <- mu.2M + eps2[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1M*mass_m[i] 
            logit(p3M[i,t]) <- mean.p3M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 4:(n_occasions-1)) {
            logit(phi3M[i,t]) <- mu.3M + epsPB[t] 
            logit(p4M[i,t]) <- mean.p4M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 5:(n_occasions-1)) {
            logit(phi4M[i,t]) <- mu.4M + epsPB[t] 
            logit(p5M[i,t]) <- mean.p5M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 6:(n_occasions-1)) {
            logit(phi5M[i,t]) <- mu.5M + epsPB[t] 
            logit(pBM[i,t]) <- mean.pBM + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 7:(n_occasions-1)) {
            logit(phiBM[i,t]) <- mu.BM + epsBM[t] 
    }
} #i male
  
### Priors
    mean.psi3 <- log(int.psi3/(1-int.psi3))
    mean.psi4 <- log(int.psi4/(1-int.psi4))
    mean.psi5 <- log(int.psi5/(1-int.psi5))
    mean.psiB <- log(int.psiB/(1-int.psiB))
    mean.psiNB <- log(int.psiNB/(1-int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pB <- log(int.pB/(1 - int.pB))
    mean.pNB <- log(int.pNB/(1 - int.pNB))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pBM <- log(int.pBM/(1 - int.pBM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pB ~ dunif(0,1)
    int.pNB ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pBM ~ dunif(0,1)
    mu.P <- log(int.phiP/(1 - int.phiP))
    mu.1 <- log(int.phi1/(1 - int.phi1))
    mu.2 <- log(int.phi2/(1 - int.phi2))
    mu.3 <- log(int.phi3/(1 - int.phi3))
    mu.4 <- log(int.phi4/(1 - int.phi4))
    mu.5 <- log(int.phi5/(1 - int.phi5))
    mu.B <- log(int.phiB/(1 - int.phiB))
    mu.NB <- log(int.phiNB/(1 - int.phiNB))
    mu.PM <- log(int.phiPM/(1 - int.phiPM))
    mu.1M <- log(int.phi1M/(1 - int.phi1M))
    mu.2M <- log(int.phi2M/(1 - int.phi2M))
    mu.3M <- log(int.phi3M/(1 - int.phi3M))
    mu.4M <- log(int.phi4M/(1 - int.phi4M))
    mu.5M <- log(int.phi5M/(1 - int.phi5M))
    mu.BM <- log(int.phiBM/(1 - int.phiBM))
    int.phiP ~ dunif(0,1)
    int.phi1 ~ dunif(0,1)
    int.phi2 ~ dunif(0,1)
    int.phi3 ~ dunif(0,1)
    int.phi4 ~ dunif(0,1)
    int.phi5 ~ dunif(0,1)
    int.phiB ~ dunif(0,1)
    int.phiNB ~ dunif(0,1)
    int.phiPM ~ dunif(0,1)
    int.phi1M ~ dunif(0,1)
    int.phi2M ~ dunif(0,1)
    int.phi3M ~ dunif(0,1)
    int.phi4M ~ dunif(0,1)
    int.phi5M ~ dunif(0,1)
    int.phiBM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -5 #0 on probability scale

    b.eff[1] <- 0
    b.eff[2] ~ dnorm(0, 0.001)
    
    for (t in 1:(n_occasions)) {
      eps.p[t] ~ dnorm(0, sd = sigma.p)
    }

    sigma.p ~ dexp(1)
    
    for (t in 1:(n_occasions-1)){
      epsP[t] ~ dnorm(0, sd = sigmaP)
      phiP.prob[t] <- 1/(1+exp(-(mu.P + epsP[t] + b.vwndP*vwnd[t] + b.npgoP*npgo[t] +
              b.albsaP*albsa[t] + b.AOIP*AOI[t] + b.upP*upwell[t] + b.chlaP*chla[t])))
      phiPM.prob[t] <- 1/(1+exp(-(mu.PM + epsP[t] + b.vwndP*vwnd[t] + b.npgoP*npgo[t] +
              b.albsaP*albsa[t] + b.AOIP*AOI[t] + b.upP*upwell[t] + b.chlaP*chla[t])))
          } 

    for (t in 2:(n_occasions-1)) {
      eps1[t] ~ dnorm(0, sd = sigma1)
      phi1.prob[t] <- 1/(1+exp(-(mu.1 + eps1[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
      phi1M.prob[t] <- 1/(1+exp(-(mu.1M + eps1[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
    }
    
    for (t in 3:(n_occasions-1)) {
      eps2[t] ~ dnorm(0, sd = sigma2)
      phi2.prob[t] <- 1/(1+exp(-(mu.2 + eps2[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
      phi2M.prob[t] <- 1/(1+exp(-(mu.2M + eps2[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
    }
#first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
    for (t in 4:(n_occasions-1)) { 
      eps.psiPB[t] ~ dnorm(0, sd = sigma.psiPB)
      epsPB[t] ~ dnorm(0, sd = sigmaPB)
      phi3.prob[t] <- 1/(1+exp(-(mu.3 + epsPB[t])))
      phi3M.prob[t] <- 1/(1+exp(-(mu.3M + epsPB[t])))
      psi3.prob[t] <- 1/(1+exp(-(mean.psi3 + eps.psiPB[t] + b.albsa.psi*albsa[t] + b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] + b.chla.psi*chla[t] + b.vwnd.psi*vwnd[t] + b.npgo.psi*npgo[t])))
    } #t
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      eps.psiB[t] ~ dnorm(0, sd = sigma.psiB)
      epsB[t] ~ dnorm(0, sd = sigmaB)
      epsBM[t] ~ dnorm(0, sd = sigmaB)
      phi4.prob[t] <- 1/(1+exp(-(mu.4 + epsPB[t])))
      phi4M.prob[t] <- 1/(1+exp(-(mu.4M + epsPB[t])))
      psi4.prob[t] <- 1/(1+exp(-(mean.psi4 + eps.psiPB[t] + b.albsa.psi*albsa[t] + b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] + b.chla.psi*chla[t] + b.vwnd.psi*vwnd[t] + b.npgo.psi*npgo[t])))
      psiB.prob[t] <- 1/(1+exp(-(mean.psiB + eps.psiB[t] + b.albsa.psiB*albsa[t] + b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] + b.chla.psiB*chla[t] + b.vwnd.psiB*vwnd[t] + b.npgo.psiB*npgo[t])))
      phiB.prob[t] <- 1/(1+exp(-(mu.B + epsB[t])))
      phiBM.prob[t] <- 1/(1+exp(-(mu.BM + epsBM[t])))
    } #t
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {
    eps.psiNB[t] ~ dnorm(0, sd = sigma.psiNB)
    epsNB[t] ~ dnorm(0, sd = sigmaNB)
    
      phi5.prob[t] <- 1/(1+exp(-(mu.5 + epsPB[t])))
      phi5M.prob[t] <- 1/(1+exp(-(mu.5M + epsPB[t])))
      psi5.prob[t] <- 1/(1+exp(-(mean.psi5 + eps.psiPB[t] + b.albsa.psi*albsa[t] + b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] + b.chla.psi*chla[t] + b.vwnd.psi*vwnd[t] + b.npgo.psi*npgo[t])))
      psiNB.prob[t] <- 1/(1+exp(-(mean.psiNB + eps.psiNB[t] + b.albsa.psiB*albsa[t] + b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] + b.chla.psiB*chla[t] + b.vwnd.psiB*vwnd[t] + b.npgo.psiB*npgo[t])))
      phiNB.prob[t] <- 1/(1+exp(-(mu.NB + epsNB[t])))

    } #t

  #shrinkage
    sigmaP ~ dexp(1)
    sigma1 ~ dexp(1)
    sigma2 ~ dexp(1)
    sigmaPB ~ dexp(1)
    sigmaB ~ dexp(1)
    sigmaNB ~ dexp(1)
    sigma.psiPB ~ dexp(1)
    sigma.psiB ~ dexp(1)
    sigma.psiNB ~ dexp(1)
    
    #covs - psi 
    b.mass.psi ~ dnorm(0, sd = s.mass.psi)
    s.mass.psi ~ dexp(1)
    b.mass.psiB ~ dnorm(0, sd = s.mass.psiB)
    s.mass.psiB ~ dexp(1)
    
    b.npgo.psi ~ dnorm(0, sd = s.npgo.psi)
    s.npgo.psi ~ dexp(1)
    b.npgo.psiB ~ dnorm(0, sd = s.npgo.psiB)
    s.npgo.psiB ~ dexp(1)
    
    b.albsa.psi ~ dnorm(0, sd = s.albsa.psi)
    s.albsa.psi ~ dexp(1)
    b.albsa.psiB ~ dnorm(0, sd = s.albsa.psiB)
    s.albsa.psiB ~ dexp(1)
    
    b.vwnd.psi ~ dnorm(0, sd = s.vwnd.psi)
    s.vwnd.psi ~ dexp(1)
    b.vwnd.psiB ~ dnorm(0, sd = s.vwnd.psiB)
    s.vwnd.psiB ~ dexp(1)

    b.chla.psi ~ dnorm(0, sd = s.chla.psi)
    s.chla.psi ~ dexp(1)
    b.chla.psiB ~ dnorm(0, sd = s.chla.psiB)
    s.chla.psiB ~ dexp(1)
    
    b.up.psi ~ dnorm(0, sd = s.up.psi)
    s.up.psi ~ dexp(1)
    b.up.psiB ~ dnorm(0, sd = s.up.psiB)
    s.up.psiB ~ dexp(1)
    
    b.AOI.psi ~ dnorm(0, sd = s.AOI.psi)
    s.AOI.psi ~ dexp(1)
    b.AOI.psiB ~ dnorm(0, sd = s.AOI.psiB)
    s.AOI.psiB ~ dexp(1)

    #covs - phi
    b.massP ~ dnorm(0, sd = s.massP)
    s.massP ~ dexp(1)
    b.massPM ~ dnorm(0, sd = s.massPM)
    s.massPM ~ dexp(1)
    b.mass1 ~ dnorm(0, sd = s.mass1)
    s.mass1 ~ dexp(1)
    b.mass1M ~ dnorm(0, sd = s.mass1M)
    s.mass1M ~ dexp(1)
    
    b.chlaP ~ dnorm(0, sd = s.chlaP)
    s.chlaP ~ dexp(1)
    b.chla1 ~ dnorm(0, sd = s.chla1)
    s.chla1 ~ dexp(1)

    b.upP ~ dnorm(0, sd = s.upP)
    s.upP ~ dexp(1)
    b.up1 ~ dnorm(0, sd = s.up1)
    s.up1 ~ dexp(1)

    b.npgoP ~ dnorm(0, pow(s.npgoP,-2))
    s.npgoP ~ dexp(1)
    b.npgo1 ~ dnorm(0, pow(s.npgo1,-2))
    s.npgo1 ~ dexp(1)

    b.albsaP ~ dnorm(0, pow(s.albsaP,-2))
    s.albsaP ~ dexp(1)
    b.albsa1 ~ dnorm(0, pow(s.albsa1,-2))
    s.albsa1 ~ dexp(1)

    b.AOIP ~ dnorm(0, pow(s.AOIP,-2))
    s.AOIP ~ dexp(1)
    b.AOI1 ~ dnorm(0, pow(s.AOI1,-2))
    s.AOI1 ~ dexp(1)

    b.vwndP ~ dnorm(0, pow(s.vwndP,-2))
    s.vwndP ~ dexp(1)
    b.vwnd1 ~ dnorm(0, pow(s.vwnd1,-2))
    s.vwnd1 ~ dexp(1)
    
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    } #t likelihood fem
} #i likelihood fem
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1], pBM = pBM[i,t-1])
    } # likelihood t male
   } #likelihood i male
    
}) # mod   

##### run model ####

nim.data <- list(y = y, ym = ym, 
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], n_occasions = n_occasions, 
                      resights = res_mat, eff = eff, mass_f = mass_f, mass_m = mass_m,
                      chla = chla, npgo = npgo, albsa = albsa, vwnd = vwnd, AOI = AOI, upwell = upwell, 
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiP = 0.9, int.phiPM = 0.9, int.phi1 = 0.9, int.phi1M = 0.9,
              int.phi2 = 0.9, int.phi2M = 0.9, int.phi3 = 0.9, int.phi3M = 0.9,
              int.phi4 = 0.9, int.phi4M = 0.9, int.phi5 = 0.9, int.phi5M = 0.75,
              int.phiB = 0.9, int.phiBM = 0.8, int.phiNB = 0.9, 
              mean.psi3 = qlogis(0.25), mean.psi4 = qlogis(0.6), mean.psi5 = qlogis(0.25),
              mean.psiB = qlogis(0.9), 
              mean.p1 = qlogis(0.7), mean.p2 = qlogis(0.6),
              mean.p3 = qlogis(0.6),mean.p4 = qlogis(0.6),
              mean.p5 = qlogis(0.4), mean.pB = 0.8, mean.pNB = qlogis(0.4),
              mean.p1M = qlogis(0.5), mean.p2M = qlogis(0.5), mean.p3M = qlogis(0.5), 
              mean.p4M = qlogis(0.5), mean.pBM = qlogis(0.8), mean.p5M = qlogis(0.6),
              eps.p = c(rep(0, n_occasions)), 
              epsP = rep(0, n_occasions-1), eps1 = rep(0, n_occasions-1), eps2 = rep(0, n_occasions-1),
              epsPB = rep(0, n_occasions-1), epsB = rep(0, n_occasions-1), 
              epsNB = rep(0, n_occasions-1), epsBM = rep(0, n_occasions-1),
              eps.psiPB = rep(0, n_occasions-1), 
              eps.psiB = rep(0, n_occasions-1), eps.psiNB = rep(0, n_occasions-1),
              sigmaPB = 1, sigmaP = 1, sigmaB = 1, sigma2 = 1, sigma1 = 1, 
              p.delB = c(0.4, 0.5, 0.75), 
              b.massP = 0, b.massPM = 0, b.mass.psi = 0, b.mass.psiB = 0,
              b.mass1 = 0, b.mass1M = 0, 
              b.chlaP = 0, b.chla1 = 0,
              b.albsaP = 0, b.albsa1 = 0,
              b.upP = 0, b.up1 = 0,
              b.vwndP = 0, b.vwnd1 = 0,
              b.AOIP = 0, b.AOI1 = 0,
              b.npgoP = 0, b.npgo1 = 0,
              b.albsa.psi = 0, b.albsa.psiB = 0,
              b.chla.psi = 0, b.chla.psiB = 0, 
              b.AOI.psi = 0, b.AOI.psiB = 0,
              b.up.psi = 0, b.up.psiB = 0,
              b.npgo.psi = 0, b.npgo.psiB = 0,
              b.vwnd.psi = 0, b.vwnd.psiB = 0,
              z = z.init, zm = z.init.m)

### parameters
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pB', 'mean.pNB',
            'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pBM', 
            "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB',
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pB', 'int.pNB', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pBM',  
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB',
            'int.phiP', 'int.phi1', 'int.phi2', 'int.phi3', 'int.phi4', 'int.phi5', 
            'int.phiB', 'int.phiNB',
            'int.phiPM', 'int.phi1M', 'int.phi2M', 'int.phi3M', 'int.phi4M', 'int.phi5M', 'int.phiBM',
            'epsP', 'eps1', 'eps2', 'epsPB','epsB', 'epsNB', 'epsBM',
            'eps.psiPB', 'eps.psiB', 'eps.psiNB',
            'b.delB', 'p.delB', 'b.eff', 'eps.p', 
            'sigmaP', 'sigma1', 'sigma2', 'sigmaPB', 'sigmaB', 'sigmaNB',
            'sigma.psiPB', 'sigma.psiB', 'sigma.psiNB', 'sigma.p', 
            'nat_all', 'nat4', 'nat5', 'nat6plus',
            'b.AOIP', 'b.AOI1',
            'b.upP', 'b.up1',
            'b.chlaP', 'b.chla1',
            'b.albsaP', 'b.albsa1',
            'b.npgoP', 'b.npgo1',
            'b.vwndP', 'b.vwnd1',
            'b.chla.psi', 'b.chla.psiB',
            'b.vwnd.psi', 'b.vwnd.psiB',
            'b.up.psi', 'b.up.psiB',
            'b.AOI.psi', 'b.AOI.psiB',
            'b.albsa.psi', 'b.albsa.psiB',
            'b.npgo.psi', 'b.npgo.psiB',
            'b.massP', 'b.mass1', 'b.massPM', 'b.mass1M', 'b.mass.psi', 'b.mass.psiB',
            'z', 'zm', 
            'phiP.prob', 'phi1.prob', 'phi2.prob', 'phi3.prob', 'phi4.prob', 'phi5.prob',
            'phiPM.prob', 'phi1M.prob', 'phi2M.prob', 'phi3M.prob', 'phi4M.prob', 'phi5M.prob',
            'phiB.prob', 'phiNB.prob', 'phiBM.prob',
            'psi3.prob', 'psi4.prob', 'psi5.prob', 'psiB.prob', 'psiNB.prob',
            'mu.P', 'mu.1', 'mu.2', 'mu.3', 'mu.4', 'mu.5', 'mu.B', 'mu.NB', 
            'mu.PM', 'mu.1M', 'mu.2M', 'mu.3M', 'mu.4M', 'mu.5M', 'mu.BM')

### run model
n.iter = 45000; n.chains = 3; n.burnin = 25000; nthin = 2; nAdapt = 10

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)


Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)


```


##### Models for individuals branded in the western portion of the range

```{r load data WALEU and CALEU}

#capture histories
ch_fem <- read.csv(here::here('data', 'ProcData', 'ch_fem_WEST.csv'), 
                   header = T, stringsAsFactors = F) %>%
  transform(Sex = ifelse(Sex == 'FALSE', 'F', NA))
ch_male <- read.csv(here::here('data', 'ProcData', 'ch_m_WEST.csv'), 
                    header = T, stringsAsFactors = F)

#number of times seen per year
resights <- read.csv(here::here('data','ProcData', 'num_resight_WEST.csv'), 
                     header = T, stringsAsFactors = F) 

n_occasions <- dim(ch_fem)[2]-7 #subtract id columns
res_mat <- as.matrix(resights[,2:9]) #1: 1-2 resights, 2: 3-8, 3: 9+, 4: ND

mass_f_waleu <- ch_fem$Mass_std
mass_m_waleu <- ch_male$Mass_std

```

```{r waleu ocean}

#adjusted year is the phi period (adj year == 1 is pups born in 2000 surviving to 2001)
#fall and summer adj_year 0 == NA (would be Sept-Dec 1999)
#spring and winter adj_year 18 == NA (would be Jan-May 2018, for pups born in 2017)

#range-wide
ocean_SSL <- read.csv(here::here('data', 'ProcData', 'ocean_all_adj_west.csv'), 
                      stringsAsFactors = F, header = T) %>%
  filter(adj_year > 0 & adj_year < 19) 

#adj_year 1 = survival from 2000 to 2001; 18 = survival from 2017 to 2018
#adj_year 12 = survival from 2011 to 2012; 18 = from 2017 to 2018
start <- 12; stop <- 18
seas <- 'NB'
seas <- 'spr'
seas <- 'sum'
seas <- 'fall'
seas <- 'win'

albsa <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$ALBSA_', seas, '[', start,':', stop,']')))))
PDO <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$PDO_', seas, '[', start,':', stop,']')))))
AOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$AOI_', seas, '[', start,':', stop,']')))))
upwell <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$upwell_', seas, '[', start,':', stop,']')))))
chla <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$chla_', seas, '[', start,':', stop,']')))))
sst <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$sst_', seas, '[', start,':', stop,']')))))
vwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$vwnd_', seas, '[', start,':', stop,']')))))
curl <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$curl_', seas, '[', start,':', stop,']')))))
prod <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$prod_', seas, '[', start,':', stop,']')))))
scal <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$scalar_', seas, '[', start,':', stop,']')))))
npgo <- eval(parse(text = paste0('ocean_SSL$NPGO_', seas, '[', start,':', stop,']')))

# fix NA values
albsa[is.na(albsa)] <- 0
PDO[is.na(PDO)] <- 0
AOI[is.na(AOI)] <- 0
upwell[is.na(upwell)] <- 0
npgo[is.na(npgo)] <- 0
chla[is.na(chla)] <- 0
sst[is.na(sst)] <- 0
vwnd[is.na(vwnd)] <- 0
prod[is.na(prod)] <- 0
curl[is.na(curl)] <- 0
scal[is.na(scal)] <- 0

### Correlations
# library(Hmisc)
# 
# ## single season - all variables
# flattenCorrMatrix <- function(cormat, pmat) {
#   ut <- upper.tri(cormat)
#   data.frame(
#     row = rownames(cormat)[row(cormat)[ut]],
#     column = rownames(cormat)[col(cormat)[ut]],
#     cor  =(cormat)[ut],
#     p = pmat[ut]
#   )
# }
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('NB', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)

#NB: PDO/MEI, PDO/NOI, MEI/NOI/NPI, albsa/vwnd, albsa/NPI
#spring: PDO/NOI, PDO/NPI, upwell/NPI, vwnd/albsa, uwnd/NOI, curl/NPGO
#summer: PDO/MEI, PDO/NPGO, AOI/NPI, albsa/chla
#fall: PDO/NOI, PDO/MEI, NOI/MEI, ssh/NPI, temp/so
#winter: PDO/MEI, PDO/NOI, MEI/NPI, vwnd/albsa, albsa/MEI, prod/scalar

```

```{r fc inits west}

##female (same as range-wide)
#first capture
get.first <- function(x) min(which(x != 11)) #include animals branded as non-pups
fc <- apply(ch_fem[,-c(1:7)], 1, get.first)

ch <- ch_fem[,-c(1:7)]
for (i in 1:dim(ch)[1]) {
  if(fc[i] > 1) {ch[i, 1:(fc[i]-1)] <- NA }
}

y <- as.matrix(ch)

cjs.me.init <- function(ch, fc){
  inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
  for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){   
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 7} #all 4yrs are (pre-)breeders
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 8} #all 5yrs are breeders
      if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 9} #all 6yrs+ are breeders
  } #i
  return(inits)
}

z.init = as.matrix(cjs.me.init(ch, fc))
#if giving latent z.st as data, change z.init in these ways:
z.init[which(y < 5)] <- NA #all obs pre-breeders are known state, so don't estimate
z.init[which(y == 6)] <- NA  #all obs w pup are known state, don't estimate
z.init[which(y == 8)] <- NA
z.init[which(y == 10)] <- NA

#want NAs where we're estimating, minus ==1 since that is set in the model
z.st <- as.matrix(ch)
z.st[which(z.st == 1)] <- NA
z.st[which(z.st == 11)] <- NA #all ND are unknown state
z.st[which(z.st == 5)] <- NA  #all obs w/o pup are unknown state, otherwise state can be obs equivalent
z.st[which(z.st == 7)] <- NA
z.st[which(z.st == 9)] <- NA
z.st[which(z.st == 6)] <- 7 #obs of 6 is state 7
z.st[which(z.st == 10)] <- 9 #obs of 10 is state 9; obs of 8 is state 8 leave as is

#male (different than above)
#first capture
get.first.m <- function(x) min(which(x != 8)) #include animals branded as non-pups
fc_m <- apply(ch_male[,-c(1:7)], 1, get.first.m)

ch_m <- ch_male[,-c(1:7)]
for (i in 1:dim(ch_m)[1]) {
  if(fc_m[i] > 1) {ch_m[i, 1:(fc_m[i]-1)] <- NA } #everything NA before first capture
}

ym <- as.matrix(ch_m)

cjs.me.init.m <- function(ch, fc) {
    inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
    for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){    
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 5} #4 yr old
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 6} #5 yr olds
     if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 7} #start all breeding adult age animals at 7
  } #i
  return(inits)
}

z.init.m = as.matrix(cjs.me.init.m(ch_m, fc_m))
#if giving latent z.st as data, change z.init in these ways:
z.init.m[which(ym == 1)] <- NA
z.init.m[which(ym == 2)] <- NA
z.init.m[which(ym == 3)] <- NA
z.init.m[which(ym == 4)] <- NA
z.init.m[which(ym == 5)] <- NA
z.init.m[which(ym == 6)] <- NA
z.init.m[which(ym == 7)] <- NA

#known latent state
z.st.m <- as.matrix(ch_m)

#set instances where males were seen as non-breeder between breeding years as a breeder since we're assuming territorial males stay that way, with known state of 7, so need a get first and get last for breeding
get.first.B <- function(x) min(which(x == 7))
fb <- apply(ch_male[,-c(1:7)], 1, get.first.B) #inf warnings for animals never seen as a breeder
get.last.B <- function(x) max(which(x == 7)) 
lb <- apply(ch_male[,-c(1:7)], 1, get.last.B)

#want NAs where we're estimating, minus == 1 since that is set in the model
z.st.m[which(z.st.m == 1)] <- NA
z.st.m[which(z.st.m == 8)] <- NA #not detected

#breeder between breeding observations
for (i in 1:dim(z.st.m)[1]) {
  if (fb[i] != Inf) {
    z.st.m[i, (fb[i]:lb[i])] <- 7
  }
}

z.init.m[which(z.st.m == 7)] <- NA #need to get the between-breeder observations for inits too

```

```{r full model text west}

# Specify model
SSL_CJS <- nimbleCode({
  
  # Priors and constraints; 
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.phi[1] + 
              b.upP*upwell[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              b.AOIP*AOI[t] +
              b.massP*mass_f[i]
            logit(phi1[i,t]) <- mu.phi[2] +             
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.AOI1*AOI[t] +
              b.mass1*mass_f[i]
            logit(phi2[i,t]) <- mu.phi[3] + 
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.AOI1*AOI[t] +
              b.mass1*mass_f[i]
            logit(phi3[i,t]) <- mu.phi[4]
            logit(phi4[i,t]) <- mu.phi[5] 
            logit(phi5[i,t]) <- mu.phi[6]
            logit(phiB[i,t]) <- mu.A 
            logit(phiNB[i,t]) <- mu.A 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 
            logit(p2[i,t]) <- mean.p2 
            logit(p3[i,t]) <- mean.p3 
            logit(p4[i,t]) <- mean.p4 
            logit(p5[i,t]) <- mean.p5 
            logit(pB[i,t]) <- mean.pA 
            logit(pNB[i,t]) <- mean.pA 
            logit(psi3[i,t]) <- mean.psi3 + b.mass.psi*mass_f[i] 
           logit(psi4[i,t]) <- mean.psi4 + b.mass.psi*mass_f[i] 
            logit(psi5[i,t]) <- mean.psi5 + b.mass.psi*mass_f[i] 
            logit(psiB[i,t]) <- mean.psiB #+ b.mass.psiB*mass_f[i] 
            logit(psiNB[i,t]) <- mean.psiNB #+ b.mass.psiB*mass_f[i]
        }
}
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
  }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.phiM[1] + 
              b.upP*upwell[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              b.AOIP*AOI[t] +
              b.massPM*mass_m[i]
            logit(phi1M[i,t]) <- mu.phiM[2] + 
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.AOI1*AOI[t] +
              b.mass1M*mass_m[i]
            logit(phi2M[i,t]) <- mu.phiM[3] + 
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.AOI1*AOI[t] +
              b.mass1M*mass_m[i]
            logit(phi3M[i,t]) <- mu.phiM[4] 
            logit(phi4M[i,t]) <- mu.phiM[5] 
            logit(phi5M[i,t]) <- mu.phiM[6] 
            logit(phiBM[i,t]) <- mu.AM 
            logit(p1M[i,t]) <- mean.p1M 
            logit(p2M[i,t]) <- mean.p2M 
            logit(p3M[i,t]) <- mean.p3M 
            logit(p4M[i,t]) <- mean.p4M 
            logit(p5M[i,t]) <- mean.p5M 
            logit(pBM[i,t]) <- mean.pAM
        }
}
  
    #priors
    mean.psi3 <- log(int.psi3/(1 - int.psi3))
    mean.psi4 <- log(int.psi4/(1 - int.psi4))
    mean.psi5 <- log(int.psi5/(1 - int.psi5))
    mean.psiB <- log(int.psiB/(1 - int.psiB))
    mean.psiNB <- log(int.psiNB/(1 - int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    mean.p1 <- log(int.p1/(1-int.p1))
    int.p1 ~ dunif(0,1)
    mean.p2 <- log(int.p2/(1-int.p2))
    int.p2 ~ dunif(0,1)
    mean.p3 <- log(int.p3/(1-int.p3))
    int.p3 ~ dunif(0,1)
    mean.p4 <- log(int.p4/(1-int.p4))
    int.p4 ~ dunif(0,1)
    mean.p5 <- log(int.p5/(1-int.p5))
    int.p5 ~ dunif(0,1)
    mean.pA <- log(int.pA/(1-int.pA))
    int.pA ~ dunif(0,1)
    
    mean.p1M <- log(int.p1M/(1-int.p1M))
    int.p1M ~ dunif(0,1)
    mean.p2M <- log(int.p2M/(1-int.p2M))
    int.p2M ~ dunif(0,1)
    mean.p3M <- log(int.p3M/(1-int.p3M))
    int.p3M ~ dunif(0,1)
    mean.p4M <- log(int.p4M/(1-int.p4M))
    int.p4M ~ dunif(0,1)
    mean.p5M <- log(int.p5M/(1-int.p5M))
    int.p5M ~ dunif(0,1)
    mean.pAM <- log(int.pAM/(1-int.pAM))
    int.pAM ~ dunif(0,1)

  ## survival
  #females
  mu.phi[1:6] ~ dmnorm(zeros[1:6], P[1:6,1:6])

  for(i in 1:6) zeros[i] <- 0 
  P[1:6,1:6] <- tau.phi*Q[1:6,1:6]
  tau.phi <- 1/(sigma.phi*sigma.phi)
  sigma.phi ~ dexp(rate) 

  #males
  mu.phiM[1:6] ~ dmnorm(zeros.m[1:6], P.m[1:6,1:6])

  for(i in 1:6) zeros.m[i] <- 0 
  P.m[1:6,1:6] <- tau.phiM*Q[1:6,1:6]
  tau.phiM <- 1/(sigma.phiM*sigma.phiM)
  sigma.phiM ~ dexp(rate)
  
    mu.A <- log(int.phiA/(1 - int.phiA))
    mu.AM <- log(int.phiAM/(1 - int.phiAM))
    int.phiA ~ dunif(0,1)
    int.phiAM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -2 #0 on probability scale
    
    #phi mass
    b.massP ~ dnorm(0, sd = s.massP)
    s.massP ~ dexp(rate)
    b.mass1 ~ dnorm(0, sd = s.mass1)
    s.mass1 ~ dexp(rate)
    b.massPM ~ dnorm(0, sd = s.massPM)
    s.massPM ~ dexp(rate)
    b.mass1M ~ dnorm(0, sd = s.mass1M)
    s.mass1M ~ dexp(rate)
    b.mass.psi ~ dnorm(0, sd = s.mass.psi)
    s.mass.psi ~ dexp(rate)
    
    # #env covs - phi
    b.upP ~ dnorm(0, sd = s.upP)
    s.upP ~ dexp(rate)
    b.up1 ~ dnorm(0, sd = s.up1)
    s.up1 ~ dexp(rate)
    
    b.npgoP ~ dnorm(0, sd = s.npgoP)
    s.npgoP ~ dexp(rate)
    b.npgo1 ~ dnorm(0, sd = s.npgo1)
    s.npgo1 ~ dexp(rate)
 
    b.AOIP ~ dnorm(0, pow(s.AOIP,-2))
    s.AOIP ~ dexp(rate)
    b.AOI1 ~ dnorm(0, pow(s.AOI1,-2))
    s.AOI1 ~ dexp(rate)
     
    b.vwndP ~ dnorm(0, pow(s.vwndP,-2))
    s.vwndP ~ dexp(rate)
    b.vwnd1 ~ dnorm(0, pow(s.vwnd1,-2))
    s.vwnd1 ~ dexp(rate)
 
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    }
}
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1],
                                    pBM = pBM[i,t-1])
    }
   }
    
}) # mod  


#seasonal loop
for (seas in c('spr', 'sum', 'fall', 'win')) {
  start <- 12; stop <- 18
  
  albsa <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$ALBSA_', seas, '[', start,':', stop,']')))))
  AOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$AOI_', seas, '[', start,':', stop,']')))))
  upwell <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$upwell_', seas, '[', start,':', stop,']')))))
  chla <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$chla_', seas, '[', start,':', stop,']')))))
  sst <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$sst_', seas, '[', start,':', stop,']')))))
  vwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$vwnd_', seas, '[', start,':', stop,']')))))
  curl <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$curl_', seas, '[', start,':', stop,']')))))
  prod <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$prod_', seas, '[', start,':', stop,']')))))
  scal <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$scalar_', seas, '[', start,':', stop,']')))))
  npgo <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$NPGO_', seas, '[', start,':', stop,']')))))

  # fix NA values
  albsa[is.na(albsa)] <- 0
  AOI[is.na(AOI)] <- 0
  upwell[is.na(upwell)] <- 0
  chla[is.na(chla)] <- 0
  sst[is.na(sst)] <- 0
  vwnd[is.na(vwnd)] <- 0
  prod[is.na(prod)] <- 0
  curl[is.na(curl)] <- 0
  scal[is.na(scal)] <- 0
  npgo[is.na(npgo)] <- 0

#data
nim.data <- list(y = y, ym = ym, 
                Q = matrix(c(1,-2,1,0,0,0,
                             -2,5,-4,1,0,0,
                             1,-4,6,-4,1,0,
                             0,1,-4,6,-4,1,
                             0,0,1,-4,5,-2,
                             0,0,0,1,-2,1), ncol = 6, nrow = 6, byrow = T),
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], n_occasions = n_occasions,
                      resights = res_mat, 
                      mass_f = mass_f_waleu, mass_m = mass_m_waleu,
                      rate = 1, AOI = AOI, vwnd = vwnd, npgo = npgo, upwell = upwell,
                      fc = fc, fc_m = fc_m)

inits <- list(mu.phiM = c(0, 0.5, 1.3, 1.6, 1.5, 2.5),
              mu.phi = c(1.1, 0.4, 0.4, 1, 1.5, 2.5), 
              sigma.phi = 1, sigma.phiM = 1,
              int.phiA = 0.9, int.phiAM = 0.9,
              mean.psi3 = -3.0, mean.psi4 = -1.5, mean.psi5 = -3.5, 
              mean.psiB = -6.0, mean.psiNB = -4.0,
              mean.pAM = -1.5, mean.p5M = -2, mean.p4M = -2.0, mean.p3M = -2, mean.p2M = -1.5,
              mean.pA = 4.0, mean.p5 = -2.5, mean.p4 = -5, mean.p3 = -4.0,
              b.mass.p = 0, b.mass.pm = 0, b.mass = 0, b.mass.m = 0,
              b.mass.psi = 0, 
              b.chlaP = 0, b.chla1 = 0,
              b.npgoP = 0, b.npgo1 = 0,
              b.upP = 0, b.up1 = 0,
              b.vwndP = 0, b.vwnd1 = 0,
              b.AOIP = 0, b.AOI1 = 0,
              z = z.init, zm = z.init.m)

# params to monitor
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pA',
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB', 
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5',
            'int.pA', 'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pAM',
            'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pAM',
            "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB', 
            'int.phiA', 'int.phiAM', 'b.massP', 'b.massPM',  'b.mass1', 'b.mass1M', 'b.mass.psi', 
            'nat_all', 'nat4', 'nat5', 'nat6plus',
            'mu.A', 'mu.AM',
            'mu.phi', 'mu.phiM', 'sigma.phi', 'sigma.phiM',
            'b.vwndP', 'b.vwnd1', 'b.upP', 'b.up1',
            'b.npgoP', 'b.npgo1', 'b.AOIP', 'b.AOI1','z', 'zm','b.delB', 'p.delB')

# MCMC settings
n.iter = 30000; n.chains = 3; n.burnin = 18000; nthin = 2; nAdapt = 4

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)

Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE, 
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)

# saveRDS(out, file = here::here('results', paste0('out_full_west_', seas, '.rds')))

} #season


```

```{r null model text west smooth age car}

#returns precision matrix weights
iar.Q <- function (n, p, return_nimble=TRUE){
  if (n < 2 * p)
    stop("n must be >= 2*p\n")
  tmp1 <- out <- matrix(0, n, n)
  tmp2 <- ((-1)^c(0:p)) * choose(p, c(0:p))
  for (i in (p + 1):n) {
    tmp1[, i] <- c(rep(0, i - p - 1), tmp2, rep(0, n - i))
  }
  for (i in n:(p + 1)) {
    tmp4 <- tmp1[, c(1:n)[tmp1[i, ] != 0]]
    tmp5 <- tmp1[i, tmp1[i, ] != 0]
    tmp6 <- t(t(tmp4) * tmp5)
    tmp6[i, ] <- 0
    out[i, ] <- -rowSums(tmp6)
  }
  out[1:p, ] <- out[n:(n - p + 1), n:1]
  out <- diag(apply(out, 1, sum)) - out
  if(!return_nimble){
    return(out)
  } else{
    A <- -out; diag(A) <- 0
    num <- rowSums(out!=0)-1
    adj <- unlist(apply(A, 1, function(v){which(v!=0)})) 
    w <- unlist(apply(A, 1, function(v)v[which(v!=0)]))
    r <- nrow(out)-sum(zapsmall(eigen(out)$values)!=0)
    return(
      list(L=length(adj), num=num, weights=w, adj=adj, c=r)
    )
  }
}

SSL_CJS <- nimbleCode({
  
# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.phi[1]
            logit(phi1[i,t]) <- mu.phi[2]
            logit(phi2[i,t]) <- mu.phi[3]
            logit(phi3[i,t]) <- mu.phi[4]
            logit(phi4[i,t]) <- mu.phi[5]
            logit(phi5[i,t]) <- mu.phi[6]
            logit(phiB[i,t]) <- mu.A
            logit(phiNB[i,t]) <- mu.A
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 
            logit(p2[i,t]) <- mean.p2 
            logit(p3[i,t]) <- mean.p3 
            logit(p4[i,t]) <- mean.p4 
            logit(p5[i,t]) <- mean.p5 
            logit(pB[i,t]) <- mean.pA 
            logit(pNB[i,t]) <- mean.pA 
            psi3[i,t] <- int.psi3
            psi4[i,t] <- int.psi4
            psi5[i,t] <- int.psi5
            psiB[i,t] <- int.psiB
            psiNB[i,t] <- int.psiNB
        }
}
  
   for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
   }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.phiM[1]
            logit(phi1M[i,t]) <- mu.phiM[2]
            logit(phi2M[i,t]) <- mu.phiM[3]
            logit(phi3M[i,t]) <- mu.phiM[4]
            logit(phi4M[i,t]) <- mu.phiM[5]
            logit(phi5M[i,t]) <- mu.phiM[6]
            logit(phiBM[i,t]) <- mu.AM
            logit(p1M[i,t]) <- mean.p1M 
            logit(p2M[i,t]) <- mean.p2M 
            logit(p3M[i,t]) <- mean.p3M 
            logit(p4M[i,t]) <- mean.p4M 
            logit(p5M[i,t]) <- mean.p5M 
            logit(pBM[i,t]) <- mean.pAM 
        }
  }
  
  ## survival
  mu.phi[1:6] ~ dcar_normal(adj[1:L], weights[1:L], num[1:6], t.mu, c)
  mu.phiM[1:6] ~ dcar_normal(adj[1:L], weights[1:L], num[1:6], t.muM, c)
    
  t.mu <- 1/(s.mu*s.mu) #precision
  s.mu ~ dexp(1) #standard deviation
  
  t.muM <- 1/(s.muM*s.muM) #precision
  s.muM ~ dexp(1) #standard deviation
  
  mu.A <- log(int.phiA/(1 - int.phiA))
  mu.AM <- log(int.phiAM/(1 - int.phiAM))
  int.phiA ~ dunif(0,1)
  int.phiAM ~ dunif(0,1)
  
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pA <- log(int.pA/(1 - int.pA))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pAM <- log(int.pAM/(1 - int.pAM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pA ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pAM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -2 #0 on probability scale

    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    } #t females
} #i females
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1

  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1],
                                    pBM = pBM[i,t-1])
    
    } #t
   } #i
    
}) # mod   

#data
Q_list <- iar.Q(6,2)

nim.data <- list(y = y, ym = ym, z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], n_occasions = n_occasions,
                      resights = res_mat, 
                      L=Q_list$L, adj=Q_list$adj,
                      weights=Q_list$weights, num=Q_list$num, c=Q_list$c,
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiA = 0.9, int.phiAM = 0.9,
              int.psi3 = 0.05, int.psi4 = 0.3, int.psi5 = 0.15, 
              int.psiB = 0.9, int.psiNB = 0.20,
              mean.pAM = 0.8, mean.p5M = 0.6,
              mu.phi = rep(qlogis(0.9),6), mu.phiM = rep(qlogis(0.9),6),
  z = z.init, zm = z.init.m)

### parameters
params <- c('int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pA', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pAM', 
            "int.psi3", 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB', 
            'nat_all', 'nat4', 'nat5', 'nat6plus', 'int.phiA', 'int.phiAM', 
            'b.delB', 'p.delB',  
            'mu.phi', 'mu.phiM', 
            'z', 'zm', 
            'mu.A', 'mu.AM')

### run model
n.iter = 30000; n.chains = 3; n.burnin = 8000; nthin = 2; nAdapt = 10

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE, enableWAIC = TRUE)

Rmcmc <- buildMCMC(conf)  
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)


```


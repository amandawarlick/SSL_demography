

```{r setup, include = F}

knitr::opts_chunk$set(echo = FALSE, eval = FALSE, message = F, warning = F)

library(here)
library(dplyr)
library(corrplot)
library(nimble)

source(here::here('scripts', 'PlotTheme.R'))

#test push new computer


```


```{r params states}
# Parameters:
# phiP surv pup to yearling
# phi1 surv of yearling
# phi2 surv of 2 year old
# phi3 surv of 3 pre-breeder
# phi4 surv of 4 pre-breeder
# phi5 surv of 5 pre-breeder
# phi4B survival of 4 year old breeders
# phi5B survival of 5 year old breeders
# phiB surv of breeders 6+ years old
# phiNB surv of n.b. breeders 5+ years old 
# phiPM surv pup to yearling male
# phi1M surv of yearling male
# phi2M surv of 2 male
# phi3M surv of 3 male
# phi4M surv of 4 male
# phi5M surv of 5+male
# phiBM surv of territorial males
# phiNBM surv of non-territorial males
    
# psi3 = prob of 3 year old becoming 4 year old B
# psi4 = prob of 4 year old becoming 5 year old B
# psi5 = prob of 5 year old becoming 6 year old B 
# psiB = prob of staying breeder given were a breeder
# psiSk = prob of becoming breeder given were a NB
# psi5M = prob of 5 yr male becoming 6 yr territorial male
# psiBM = prob of territorial male staying breeder - should be close to 1
# psiNBM = prob of non-territorial male becoming territorial breeder
    
# p1 = detection of yearling
# P2 = detection of 2
# p3 = detection of 3 (pre-breeder)
# p4 = detection of 4
# p5 = detection of 5
# pB = detection of B
# pSk = detection of Sk 
# p1M = detection of yearling male
# P2M = detection of 2 male
# p3M = detection of 3 male
# p4M = detection of 4 male
# p5M = detection of 5 male
# pBM = detection of territorial males 6+
# pNBM = detection of non-ter males 6+
    
# delPB = prob of correctly ascertaining presence of pup for prebreeders #not in model, no false + 
# delB = prob of correctly ascertaining presence of pup for breeders
# delSk = prob of correctly ascertaining presence of pup for NBs #not in model, no false +
# delBM = prob of correctly ascertaining territoriality of adult male

# OBSERVATIONS
# 1 = pup w/o
# 2 = 1 w/o
# 3 = 2 w/o
# 4 = 3 w/o
# 5 = 4 w/o
# 6 = 4 w
# 7 = 5 w/o
# 8 = 5 w
# 9 = 6+ w/o
# 10 = 6+ w
# 11 = ND
# 1 = pup male
# 2 = 1yo male
# 3 = 2yo male
# 4 = 3 male
# 5 = 4 male
# 6 = 5 male
# 7 = 6+ male territory
# 8 = 6+ male w/o territory
# 9 = ND male

# STATES
# 1 = pup
# 2 = Pre1
# 3 = Pre2
# 4 = Pre3
# 5 = Pre4
# 6 = Pre5
# 7 = 4B
# 8 = 5B
# 9 = 6+B
# 10 = 5Sk
# 11 = 6+Sk
# 12 = dead
# 1 = pup_m
# 2 = 1m
# 3 = 2m
# 4 = 3m
# 5 = 4m
# 6 = 5m
# 7 = territorial male
# 8 = non-territorial male
# 9 = D_m

#4 yo natality: 7/(5+7)
#5 yo natality: 8/(8+6+10)
#6+ yo natality: 9/(9+11)

# prop breeding
# 4b: 7/(7+8+9)
# 5b: 8/(7+8+9)
# 6b: 9/(7+8+9)

```

```{r nimble functions}

#state transition - females
getPHI_f <- nimbleFunction(
  run = function(z=double(0), phiP=double(0), phi1=double(0), phi2=double(0), phi3=double(0), phi4=double(0),
                 phi5=double(0), phiB=double(0), phiNB=double(0),
                 psi3=double(0), psi4=double(0), psi5=double(0), psiB=double(0), psiNB=double(0)) {
   returnType(double(1))
   ans <- rep(0,12)
     if(z==1)   ans <- c(0,phiP,0,0,0,0,0,0,0,0,0,1-phiP) #pup
     if(z==2)   ans <- c(0,0,phi1,0,0,0,0,0,0,0,0,1-phi1)   #yearling   
     if(z==3)   ans <- c(0,0,0,phi2,0,0,0,0,0,0,0,1-phi2)  #2yr
     if(z==4)   ans <- c(0,0,0,0,phi3*(1-psi3),0,phi3*psi3,0,0,0,0,1-phi3)  #3yr to B/PB
     if(z==5)   ans <- c(0,0,0,0,0,phi4*(1-psi4),0,phi4*psi4,0,0,0,1-phi4)    #4yr to B/PB
     if(z==6)   ans <- c(0,0,0,0,0,0,0,0,phi5*psi5,0,phi5*(1-psi5),1-phi5)    #5yr to B/NB                
     if(z==7)   ans <- c(0,0,0,0,0,0,0,phi4*psiB,0,phi4*(1-psiB),0,1-phi4)  #4B to B/NB
     if(z==8)   ans <- c(0,0,0,0,0,0,0,0,phi5*psiB,0,phi5*(1-psiB),1-phi5)       #5B to B/NB
     if(z==9)   ans <- c(0,0,0,0,0,0,0,0,phiB*psiB,0,phiB*(1-psiB),1-phiB)       #6+B to B/NB
     if(z==10)  ans <- c(0,0,0,0,0,0,0,0,phiNB*psiNB,0,phiNB*(1-psiNB),1-phiNB)   #5NB to B/NB
     if(z==11)  ans <- c(0,0,0,0,0,0,0,0,phiNB*psiNB,0,phiNB*(1-psiNB),1-phiNB)      #6+NB to B/NB
     if(z==12)  ans <- c(0,0,0,0,0,0,0,0,0,0,0,1) #D

   return(ans)
 }
)

#observations - females
getP_f <- nimbleFunction(
  run = function(z=double(0), p1=double(0), p2=double(0), p3=double(0), p4=double(0), p5=double(0),
                 pB=double(0), pNB=double(0), delB=double(0)) {
   returnType(double(1))
   ans <- rep(0,11)
     if(z==1)   ans <- c(1,0,0,0,0,0,0,0,0,0,0) #pups seen as pups
     if(z==2)   ans <- c(0,p1,0,0,0,0,0,0,0,0,1-p1)   #1yr      
     if(z==3)   ans <- c(0,0,p2,0,0,0,0,0,0,0,1-p2)   #2yr
     if(z==4)   ans <- c(0,0,0,p3,0,0,0,0,0,0,1-p3)   #3yr
     if(z==5)   ans <- c(0,0,0,0,p4,0,0,0,0,0,1-p4)    #4yr seen as PB
     if(z==6)   ans <- c(0,0,0,0,0,0,p5,0,0,0,1-p5)    #5yr seen as PB          
     if(z==7)   ans <- c(0,0,0,0,pB*(1-delB),pB*delB,0,0,0,0,1-pB)    #4yr B seen as NB/B
     if(z==8)   ans <- c(0,0,0,0,0,0,pB*(1-delB),pB*delB,0,0,1-pB)    #5yr B seen as NB/B
     if(z==9)   ans <- c(0,0,0,0,0,0,0,0,pB*(1-delB),pB*delB,1-pB)    #6+ B seen as NB/B
     if(z==10)  ans <- c(0,0,0,0,0,0,pNB,0,0,0,1-pNB) #5+ NB seen as NB
     if(z==11)  ans <- c(0,0,0,0,0,0,0,0,pNB,0,1-pNB) #6+ NB seen as NB
     if(z==12)  ans <- c(0,0,0,0,0,0,0,0,0,0,1)

   return(ans)
 }
)

#state transition - males
getPHI_m <- nimbleFunction(
  run = function(z=double(0), phiPM=double(0), phi1M=double(0), phi2M=double(0), phi3M=double(0), phi4M=double(0),
                 phi5M=double(0), phiBM=double(0)) {
   returnType(double(1))
   ans <- rep(0,8)
     if(z==1)   ans <- c(0,phiPM,0,0,0,0,0,1-phiPM) #pup
     if(z==2)   ans <- c(0,0,phi1M,0,0,0,0,1-phi1M) #yearling
     if(z==3)   ans <- c(0,0,0,phi2M,0,0,0,1-phi2M) #2yr
     if(z==4)   ans <- c(0,0,0,0,phi3M,0,0,1-phi3M) #3yr 
     if(z==5)   ans <- c(0,0,0,0,0,phi4M,0,1-phi4M) #4yr 
     if(z==6)   ans <- c(0,0,0,0,0,0,phi5M,1-phi5M) #5yr              
     if(z==7)   ans <- c(0,0,0,0,0,0,phiBM,1-phiBM) #B 
     if(z==8)   ans <- c(0,0,0,0,0,0,0,1) #D
     
   return(ans)
 }
)

#observations - males
getP_m <- nimbleFunction(
  run = function(z=double(0), p1M=double(0), p2M=double(0), p3M=double(0), p4M=double(0), p5M=double(0),
                 pBM=double(0)) {
   returnType(double(1))
   ans <- rep(0,8)
     if(z==1)   ans <- c(1,0,0,0,0,0,0,0)       #pup
     if(z==2)   ans <- c(0,p1M,0,0,0,0,0,1-p1M) #yearling    
     if(z==3)   ans <- c(0,0,p2M,0,0,0,0,1-p2M) #2yr
     if(z==4)   ans <- c(0,0,0,p3M,0,0,0,1-p3M) #3
     if(z==5)   ans <- c(0,0,0,0,p4M,0,0,1-p4M) #4 
     if(z==6)   ans <- c(0,0,0,0,0,p5M,0,1-p5M) #5               
     if(z==7)   ans <- c(0,0,0,0,0,0,pBM,1-pBM) #B
     if(z==8)   ans <- c(0,0,0,0,0,0,0,1)   #D
   return(ans)
 }
)

```


##### range-wide models

```{r load data EAST, echo = F, eval = T}

## capture histories
ch_fem <- read.csv(here::here('data', 'ProcData','ch_fem_EAST.csv'),
                   header = T, stringsAsFactors = F) %>%
  transform(Sex = ifelse(Sex == 'FALSE', 'F', NA)) 
ch_male <- read.csv(here::here('data', 'ProcData', 'ch_m_EAST.csv'),
                    header = T, stringsAsFactors = F)

#number of times seen per year
resights <- read.csv(here::here('data', 'ProcData', 'num_resight_EAST.csv'),
                     header = T, stringsAsFactors = F)

## variables and dimensions
n_occasions <- dim(ch_fem)[2]-7 #subtract id columns
res_mat <- as.matrix(resights[,2:dim(resights)[2]]) #1: 1-2 resights, 2: 3-8, 3: 9+, 4: ND

## rough estimate of effort
eff <- c(rep(1, 18))[1:18]
eff[c(6,17,18)] <- 2 #less effort in 2006, 2017-2018 (no field camps)

mass_f <- ch_fem$Mass_std
mass_m <- ch_male$Mass_std

#not ultimately estimating any regional effects
#general levels = 'W ALEU', 'Other' (reg_0b)
# region_f <- as.numeric(factor(ch_fem$reg_0c)) 
# region_m <- as.numeric(factor(ch_male$reg_0c)) 

#detailed levels = "C ALEU" "C GULF" "E ALEU" "E GULF" (reg_0)
# reg_f <- as.numeric(factor(ch_fem$reg_0)) 
# reg_m <- as.numeric(factor(ch_male$reg_0)) 

```

```{r fc inits}

##female
#first capture
get.first <- function(x) min(which(x == 1)) #pups only
# get.first <- function(x) min(which(x != 11)) #include animals branded as non-pups
fc <- apply(ch_fem[,-c(1:7)], 1, get.first)

ch <- ch_fem[,-c(1:7)]
for (i in 1:dim(ch)[1]) {
  if(fc[i] > 1) {ch[i, 1:(fc[i]-1)] <- NA }
}

y <- as.matrix(ch)

# Initial values for possible states
# "NA" for the latent state at all places before an individual was observed, 
# if t > fc & t <= fc + 3, then init = t-fc
# if t = fc + 4, then ind is 4yr, init = either 5 or 7
# if t = fc + 5, then ind is 5yr, init = either 6, 8, 10
# if t >= fc + 6, then ind is 6yr, init = either 9 or 10

cjs.me.init <- function(ch, fc){
  inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
  for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){   
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 7} #all 4yrs are (pre-)breeders
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 8} #all 5yrs are breeders
      if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 9} #all 6yrs+ are breeders
  } #i
  return(inits)
}

z.init = as.matrix(cjs.me.init(ch, fc))
#if giving latent z.st as data, change z.init in these ways:
z.init[which(y < 5)] <- NA #all obs pre-breeders are known state, so don't estimate
z.init[which(y == 6)] <- NA  #all obs w pup are known state, don't estimate
z.init[which(y == 8)] <- NA
z.init[which(y == 10)] <- NA

#want NAs where we're estimating, except state == 1 since that is set in the model
z.st <- as.matrix(ch)
z.st[which(z.st == 1)] <- NA
z.st[which(z.st == 11)] <- NA #all ND are unknown state
z.st[which(z.st == 5)] <- NA  #all obs w/o pup are unknown state, otherwise state can be obs equivalent
z.st[which(z.st == 7)] <- NA
z.st[which(z.st == 9)] <- NA
z.st[which(z.st == 6)] <- 7 #obs of 6 is state 7
z.st[which(z.st == 10)] <- 9 #obs of 10 is state 9; obs of 8 is state 8 leave as is

get.first.m <- function(x) min(which(x != 8)) #include animals branded as non-pups
fc_m <- apply(ch_male[,-c(1:7)], 1, get.first.m)

ch_m <- ch_male[,-c(1:7)]
for (i in 1:dim(ch_m)[1]) {
  if(fc_m[i] > 1) {ch_m[i, 1:(fc_m[i]-1)] <- NA } #everything NA before first capture
}

ym <- as.matrix(ch_m)

cjs.me.init.m <- function(ch, fc) {
    inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
    for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){    
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 5} #4 yr old
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 6} #5 yr olds
     if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 7} #start all adult age animals at 7
  } #i
  return(inits)
}

z.init.m = as.matrix(cjs.me.init.m(ch_m, fc_m))
#if giving latent z.st as data, change z.init in these ways:
z.init.m[which(ym == 1)] <- NA
z.init.m[which(ym == 2)] <- NA
z.init.m[which(ym == 3)] <- NA
z.init.m[which(ym == 4)] <- NA
z.init.m[which(ym == 5)] <- NA
z.init.m[which(ym == 6)] <- NA
z.init.m[which(ym == 7)] <- NA

#known latent state
z.st.m <- as.matrix(ch_m)

get.first.B <- function(x) min(which(x == 7))
fb <- apply(ch_male[,-c(1:7)], 1, get.first.B) #inf warnings for animals never seen as an adult
get.last.B <- function(x) max(which(x == 7)) 
lb <- apply(ch_male[,-c(1:7)], 1, get.last.B)

#want NAs where we're estimating, except state == 1 since that is set in the model
z.st.m[which(z.st.m == 1)] <- NA
z.st.m[which(z.st.m == 8)] <- NA #not detected

#breeder between breeding observations
for (i in 1:dim(z.st.m)[1]) {
  if (fb[i] != Inf) {
    z.st.m[i, (fb[i]:lb[i])] <- 7
  }
}

z.init.m[which(z.st.m == 7)] <- NA #need to get the between-breeder observations for inits too, not just all == 7

## recapture summary stats for manuscript ##
#i=1 lots of resights
#i=6 single resight
#i=2 no resights
# capt <- numeric()
# for (i in 1:dim(ch)[1]) {
#   capt[i] <- as.numeric(sum(ch[i,(fc[i]+1):n_occasions]<11)<1) #will be TRUE for inds never recapt
# }
# 
# #capt==1 for inds never resighted; 553/1322 == 41%
# sum(capt>0)/length(capt)
# 
# capt_m <- numeric()
# for (i in 1:dim(ch_m)[1]) {
#   capt_m[i] <- as.numeric(sum(ch_m[i,(fc_m[i]+1):n_occasions]<8)<1) #will be TRUE for inds never recapt
# }
# 
# #capt==1 for inds never resighted; 622/1330 == 47%
# sum(capt_m>0)/length(capt_m)
# 
# ## distribution of resights for females
# res_actual <- read.csv(here::here('SSL_CJS', 'Data', 'resights_actual.csv'), 
#                        header = T, stringsAsFactors = F)
# res_actual <- res_actual[,2:(n_occasions+1)]
# 
# capt_freq <- capt_sd <- numeric()
# for (i in 1:dim(res_actual)[1]) { 
# 
#   cols <- which(res_actual[i,]!=0)
#   capt_freq[i] <- mean(as.numeric(res_actual[i,cols[which(cols>fc[i])]])) #average per ind across yrs
#   capt_sd[i] <- sd(as.numeric(res_actual[i,cols[which(cols>fc[i])]])) #variability across yrs
# }

#individuals recaptured an average of 6 times per year
# capt_freq_avg <- mean(capt_freq, na.rm = T)
# #variability in recaptures across individuals: 7.1
# capt_sd_avg <- sd(capt_freq, na.rm = T) 

```

```{r ocean covariates}

#adjusted year is the phi period (adj year == 1 is pups born in 2000 surviving to 2001)
#fall and summer adj_year 0 == NA (would be Sept-Dec 1999)
#spring and winter adj_year 18 == NA (would be Jan-May 2018, for pups born in 2017)
#if want to study lag time (pups born in June 2000 strongly affected by mom's forage availability in winter 1999-2000 rather than first solo foraging winter 2000-2001), get June-Dec 1999 data exclude 1999 and 2019, just want up through May/Spring of 2018 for pups born in 2017

#range-wide
ocean_SSL <- read.csv(here::here('data', 'ProcData', 'ocean_all_adj_east.csv'), 
                      stringsAsFactors = F, header = T) %>%
  filter(adj_year > 0 & adj_year < 19) 

#adj_year 1 = survival from 2000 to 2001; 18 = survival from 2017 to 2018
start <- 1; stop <- 18
seas <- 'NB'
# seas <- 'spr'
# seas <- 'sum'
# seas <- 'fall'
# seas <- 'win'

albsa <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$ALBSA_', seas, '[', start,':', stop,']')))))
PDO <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$PDO_', seas, '[', start,':', stop,']')))))
# MEI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$MEI_', seas, '[', start,':', stop,']')))))
AOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$AOI_', seas, '[', start,':', stop,']')))))
upwell <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$upwell_', seas, '[', start,':', stop,']')))))
chla <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$chla_', seas, '[', start,':', stop,']')))))
sst <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$sst_', seas, '[', start,':', stop,']')))))
# ssh <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$ssh_', seas, '[', start,':', stop,']')))))
# mld <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$mld_', seas, '[', start,':', stop,']')))))
vwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$vwnd_', seas, '[', start,':', stop,']')))))
uwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$uwnd_', seas, '[', start,':', stop,']')))))
NOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$NOI_', seas, '[', start,':', stop,']')))))
prod <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$prod_', seas, '[', start,':', stop,']')))))
scal <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$scalar_', seas, '[', start,':', stop,']')))))
npgo <- eval(parse(text = paste0('ocean_SSL$NPGO_', seas, '[', start,':', stop,']')))

# fix NA values
albsa[is.na(albsa)] <- 0
PDO[is.na(PDO)] <- 0
# MEI[is.na(MEI)] <- 0
AOI[is.na(AOI)] <- 0
upwell[is.na(upwell)] <- 0
npgo[is.na(npgo)] <- 0
# MEI[is.na(MEI)] <- 0
# temp[is.na(temp)] <- 0
# ssh[is.na(ssh)] <- 0
# mld[is.na(mld)] <- 0
chla[is.na(chla)] <- 0
sst[is.na(sst)] <- 0
vwnd[is.na(vwnd)] <- 0
uwnd[is.na(uwnd)] <- 0
prod[is.na(prod)] <- 0
NOI[is.na(NOI)] <- 0
scal[is.na(scal)] <- 0


### Correlations
library(Hmisc)

## single season - all variables
flattenCorrMatrix <- function(cormat, pmat) {
  ut <- upper.tri(cormat)
  data.frame(
    row = rownames(cormat)[row(cormat)[ut]],
    column = rownames(cormat)[col(cormat)[ut]],
    cor  =(cormat)[ut],
    p = pmat[ut]
  )
}
cor <- rcorr(as.matrix(ocean_SSL[,grepl('win', colnames(ocean_SSL))]))
cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
         insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)

#strongly correlated variables
#NB: PDO-MEI/NOI/NPI, albsa-NPI
# spring: PDO-NOI/NPI/SST, albsa-curl, NPI-up, sst-MEI
#summer: MEI-PDO/NPGO, albsa-NPI, AOI-NPI, MEI-NOI
#fall: NOI-PDO, PDO-MEI, NOI-MEI, AOI-albsa
#winter: NPI-albsa, MEI-albsa, MEI-PDO, uwnd-PDO, curl-albsa, curl-chla

## multiple seasons
# cor <- rcorr(as.matrix(ocean_SSL[,c(2:76)]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)

#single variable across all seasons
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('PDO', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('MEI', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('sst', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('ssh', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('chla', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('mld', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('up', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('vwnd', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('AOI', colnames(ocean_SSL))])) 
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor) 
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)

```


```{r null}

SSL_CJS <- nimbleCode({

# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.P 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 + b.eff[eff[t]] 
        } #t 
  
  for (t in 2:(n_occasions-1)) {
    logit(phi1[i,t]) <- mu.1  
    logit(p2[i,t]) <- mean.p2 + b.eff[eff[t]] 
  }
  
  for (t in 3:(n_occasions-1)) {
    logit(phi2[i,t]) <- mu.2 
    logit(p3[i,t]) <- mean.p3 + b.eff[eff[t]] 
  }
  
  #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
      for (t in 4:(n_occasions-1)) { 
      logit(psi3[i,t]) <- mean.psi3 
      logit(phi3[i,t]) <- mu.3 + epsPB[t]
      logit(p4[i,t]) <- mean.p4 + b.eff[eff[t]] 
      logit(pB[i,t]) <- mean.pB + b.eff[eff[t]] 
    } #t psi
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      logit(psi4[i,t]) <- mean.psi4 
      logit(psiB[i,t]) <- mean.psiB 
      logit(phi4[i,t]) <- mu.4 
      logit(phiB[i,t]) <- mu.B 
      logit(p5[i,t]) <- mean.p5 + b.eff[eff[t]]
      logit(pNB[i,t]) <- mean.pNB + b.eff[eff[t]] 
    } #t psi
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {  
      logit(psi5[i,t]) <- mean.psi5 
      logit(psiNB[i,t]) <- mean.psiNB 
      logit(phi5[i,t]) <- mu.5 
      logit(phiNB[i,t]) <- mu.NB 
          } #t psi
} #i fem
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
    }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.PM 
            logit(p1M[i,t]) <- mean.p1M + b.eff[eff[t]] 
        } #t
    
    for (t in 2:(n_occasions-1)) {
            logit(phi1M[i,t]) <- mu.1M 
            logit(p2M[i,t]) <- mean.p2M + b.eff[eff[t]] 
          }
    for (t in 3:(n_occasions-1)) {
            logit(phi2M[i,t]) <- mu.2M 
            logit(p3M[i,t]) <- mean.p3M + b.eff[eff[t]] 
    }
    for (t in 4:(n_occasions-1)) {
            logit(phi3M[i,t]) <- mu.3M 
            logit(p4M[i,t]) <- mean.p4M + b.eff[eff[t]] 
    }
    for (t in 5:(n_occasions-1)) {
            logit(phi4M[i,t]) <- mu.4M 
            logit(p5M[i,t]) <- mean.p5M + b.eff[eff[t]] 
    }
    for (t in 6:(n_occasions-1)) {
            logit(phi5M[i,t]) <- mu.5M 
            logit(pBM[i,t]) <- mean.pBM + b.eff[eff[t]] 
    }
    for (t in 7:(n_occasions-1)) {
            logit(phiBM[i,t]) <- mu.BM  
    }
} #i male
  
### Priors
    #psi
    mean.psi3 <- log(int.psi3/(1-int.psi3))
    mean.psi4 <- log(int.psi4/(1-int.psi4))
    mean.psi5 <- log(int.psi5/(1-int.psi5))
    mean.psiB <- log(int.psiB/(1-int.psiB))
    mean.psiNB <- log(int.psiNB/(1-int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    #p
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pB <- log(int.pB/(1 - int.pB))
    mean.pNB <- log(int.pNB/(1 - int.pNB))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pBM <- log(int.pBM/(1 - int.pBM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pB ~ dunif(0,1)
    int.pNB ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pBM ~ dunif(0,1)
    #phi
    mu.P <- log(int.phiP/(1 - int.phiP))
    mu.1 <- log(int.phi1/(1 - int.phi1))
    mu.2 <- log(int.phi2/(1 - int.phi2))
    mu.3 <- log(int.phi3/(1 - int.phi3))
    mu.4 <- log(int.phi4/(1 - int.phi4))
    mu.5 <- log(int.phi5/(1 - int.phi5))
    mu.B <- log(int.phiB/(1 - int.phiB))
    mu.NB <- log(int.phiNB/(1 - int.phiNB))
    mu.PM <- log(int.phiPM/(1 - int.phiPM))
    mu.1M <- log(int.phi1M/(1 - int.phi1M))
    mu.2M <- log(int.phi2M/(1 - int.phi2M))
    mu.3M <- log(int.phi3M/(1 - int.phi3M))
    mu.4M <- log(int.phi4M/(1 - int.phi4M))
    mu.5M <- log(int.phi5M/(1 - int.phi5M))
    mu.BM <- log(int.phiBM/(1 - int.phiBM))
    int.phiP ~ dunif(0,1)
    int.phi1 ~ dunif(0,1)
    int.phi2 ~ dunif(0,1)
    int.phi3 ~ dunif(0,1)
    int.phi4 ~ dunif(0,1)
    int.phi5 ~ dunif(0,1)
    int.phiB ~ dunif(0,1)
    int.phiNB ~ dunif(0,1)
    int.phiPM ~ dunif(0,1)
    int.phi1M ~ dunif(0,1)
    int.phi2M ~ dunif(0,1)
    int.phi3M ~ dunif(0,1)
    int.phi4M ~ dunif(0,1)
    int.phi5M ~ dunif(0,1)
    int.phiBM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -5 #0 on probability scale...? help check

    b.eff[1] <- 0
    b.eff[2] ~ dnorm(0, 0.001)
    
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    } #t likelihood fem
} #i likelihood fem
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1], pBM = pBM[i,t-1])
    } # likelihood t male
   } #likelihood i male
    
}) # mod   

##### run model ####

nim.data <- list(y = y, ym = ym, 
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], 
                      n_occasions = n_occasions,
                      resights = res_mat,
                      eff = eff, mass_f = mass_f, mass_m = mass_m,
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiP = 0.9, int.phiPM = 0.9, int.phi1 = 0.9, int.phi1M = 0.9,
              int.phi2 = 0.9, int.phi2M = 0.9, int.phi3 = 0.9, int.phi3M = 0.9,
              int.phi4 = 0.9, int.phi4M = 0.9, int.phi5 = 0.9, int.phi5M = 0.75,
              int.phiB = 0.9, int.phiBM = 0.8, int.phiNB = 0.9, 
              mean.psi3 = qlogis(0.25), mean.psi4 = qlogis(0.6), mean.psi5 = qlogis(0.25),
              mean.psiB = qlogis(0.9), mean.psiNBM = 0.2, #prob scale for these
              mean.p1 = qlogis(0.7), mean.p2 = qlogis(0.6),
              mean.p3 = qlogis(0.6),mean.p4 = qlogis(0.6),
              mean.p5 = qlogis(0.4), mean.pB = 0.8, mean.pNB = qlogis(0.4),
              mean.p1M = qlogis(0.5), mean.p2M = qlogis(0.5), mean.p3M = qlogis(0.5), 
              mean.p4M = qlogis(0.5), 
              mean.pBM = qlogis(0.8), mean.p5M = qlogis(0.6),
              p.delB = c(0.4, 0.5, 0.75), 
              z = z.init, zm = z.init.m)

### parameters
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pB', 'mean.pNB',
            'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pBM', 
            "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB',
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pB', 'int.pNB', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pBM',  
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB',
            'int.phiP', 'int.phi1', 'int.phi2', 'int.phi3', 'int.phi4', 'int.phi5', 
            'int.phiB', 'int.phiNB',
            'int.phiPM', 'int.phi1M', 'int.phi2M', 'int.phi3M', 'int.phi4M', 'int.phi5M', 'int.phiBM',
            'nat_all', 'nat4', 'nat5', 'nat6plus',
            'b.delB', 'p.delB', 
            'b.eff', 
            'z', 'zm', 
            'mu.P', 'mu.1', 'mu.2', 'mu.3', 'mu.4', 'mu.5', 'mu.B', 'mu.NB', 
            'mu.PM', 'mu.1M', 'mu.2M', 'mu.3M', 'mu.4M', 'mu.5M', 'mu.BM')

### run model
# n.iter = 30; n.chains = 2; n.burnin = 10; nthin = 1; nAdapt = 4
# n.iter = 1000; n.chains = 2; n.burnin = 500; nthin = 1; nAdapt = 20
n.iter = 35000; n.chains = 3; n.burnin = 20000; nthin = 3; nAdapt = 20

start <- Sys.time()

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)


Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
# Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

# st2<-Sys.time()
out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)

elapsed <- Sys.time()-start

saveRDS(out, here::here('results', 'out_null_east.rds'))

all_pars <- colnames(out$samples$chain1)
noZ <- all_pars[which(!grepl('z', all_pars))]
rhats <- gelman.diag(out$samples[,noZ], multivariate=F, autoburnin=F)
# traceplot(out$samples[,noZ[1:45]])

```


```{r RE}

#random effects for survival, breeding probability, and detection plus pup mass covariate
#correlated random effects across several age/sex-based groups

SSL_CJS <- nimbleCode({

# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.P + epsP[t] + b.mass.p*mass_f[i] 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 + b.eff[eff[t]] + eps.p[t] 
        } #t 
  
  for (t in 2:(n_occasions-1)) {
    logit(phi1[i,t]) <- mu.1 + eps1[t] +
              b.mass.1*mass_f[i] 
    logit(p2[i,t]) <- mean.p2 + b.eff[eff[t]] + eps.p[t]
  }
  
  for (t in 3:(n_occasions-1)) {
    logit(phi2[i,t]) <- mu.2 + eps2[t] +
              b.mass.1*mass_f[i] 
    logit(p3[i,t]) <- mean.p3 + b.eff[eff[t]] + eps.p[t]
  }
  
  #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
      for (t in 4:(n_occasions-1)) { 
      logit(psi3[i,t]) <- mean.psi3 + eps.psiPB[t] +
             b.mass.psi*mass_f[i]
      logit(phi3[i,t]) <- mu.3 + epsPB[t]
      logit(p4[i,t]) <- mean.p4 + b.eff[eff[t]] + eps.p[t]
      logit(pB[i,t]) <- mean.pB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      logit(psi4[i,t]) <- mean.psi4 + eps.psiPB[t] +
              b.mass.psi*mass_f[i]
      logit(psiB[i,t]) <- mean.psiB + eps.psiB[t] +
              b.mass.psiB*mass_f[i]
      logit(phi4[i,t]) <- mu.4 + epsPB[t]
      logit(phiB[i,t]) <- mu.B + epsB[t]
      logit(p5[i,t]) <- mean.p5 + b.eff[eff[t]] + eps.p[t]
      logit(pNB[i,t]) <- mean.pNB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {  
      logit(psi5[i,t]) <- mean.psi5 + eps.psiPB[t] +
              b.mass.psi*mass_f[i]
      logit(psiNB[i,t]) <- mean.psiNB + eps.psiNB[t] +
              b.mass.psiB*mass_f[i]
      logit(phi5[i,t]) <- mu.5 + epsPB[t]
      logit(phiNB[i,t]) <- mu.NB + epsNB[t]
          } #t psi
} #i fem
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
    }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.PM + epsP[t] +
              b.mass.pm*mass_m[i] 
            logit(p1M[i,t]) <- mean.p1M + b.eff[eff[t]] + eps.p[t] 
        } #t
    
    for (t in 2:(n_occasions-1)) {
            logit(phi1M[i,t]) <- mu.1M + eps1[t] +
              b.mass.1m*mass_m[i] 
            logit(p2M[i,t]) <- mean.p2M + b.eff[eff[t]] + eps.p[t]
          }
    for (t in 3:(n_occasions-1)) {
            logit(phi2M[i,t]) <- mu.2M + eps2[t] +
              b.mass.1m*mass_m[i] 
            logit(p3M[i,t]) <- mean.p3M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 4:(n_occasions-1)) {
            logit(phi3M[i,t]) <- mu.3M + epsPB[t] 
            logit(p4M[i,t]) <- mean.p4M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 5:(n_occasions-1)) {
            logit(phi4M[i,t]) <- mu.4M + epsPB[t] 
            logit(p5M[i,t]) <- mean.p5M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 6:(n_occasions-1)) {
            logit(phi5M[i,t]) <- mu.5M + epsPB[t] 
            logit(pBM[i,t]) <- mean.pBM + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 7:(n_occasions-1)) {
            logit(phiBM[i,t]) <- mu.BM + epsBM[t] 
    }
} #i male
  
### Priors
    #psi
    mean.psi3 <- log(int.psi3/(1-int.psi3))
    mean.psi4 <- log(int.psi4/(1-int.psi4))
    mean.psi5 <- log(int.psi5/(1-int.psi5))
    mean.psiB <- log(int.psiB/(1-int.psiB))
    mean.psiNB <- log(int.psiNB/(1-int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    #p
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pB <- log(int.pB/(1 - int.pB))
    mean.pNB <- log(int.pNB/(1 - int.pNB))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pBM <- log(int.pBM/(1 - int.pBM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pB ~ dunif(0,1)
    int.pNB ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pBM ~ dunif(0,1)
    #phi
    mu.P <- log(int.phiP/(1 - int.phiP))
    mu.1 <- log(int.phi1/(1 - int.phi1))
    mu.2 <- log(int.phi2/(1 - int.phi2))
    mu.3 <- log(int.phi3/(1 - int.phi3))
    mu.4 <- log(int.phi4/(1 - int.phi4))
    mu.5 <- log(int.phi5/(1 - int.phi5))
    mu.B <- log(int.phiB/(1 - int.phiB))
    mu.NB <- log(int.phiNB/(1 - int.phiNB))
    mu.PM <- log(int.phiPM/(1 - int.phiPM))
    mu.1M <- log(int.phi1M/(1 - int.phi1M))
    mu.2M <- log(int.phi2M/(1 - int.phi2M))
    mu.3M <- log(int.phi3M/(1 - int.phi3M))
    mu.4M <- log(int.phi4M/(1 - int.phi4M))
    mu.5M <- log(int.phi5M/(1 - int.phi5M))
    mu.BM <- log(int.phiBM/(1 - int.phiBM))
    int.phiP ~ dunif(0,1)
    int.phi1 ~ dunif(0,1)
    int.phi2 ~ dunif(0,1)
    int.phi3 ~ dunif(0,1)
    int.phi4 ~ dunif(0,1)
    int.phi5 ~ dunif(0,1)
    int.phiB ~ dunif(0,1)
    int.phiNB ~ dunif(0,1)
    int.phiPM ~ dunif(0,1)
    int.phi1M ~ dunif(0,1)
    int.phi2M ~ dunif(0,1)
    int.phi3M ~ dunif(0,1)
    int.phi4M ~ dunif(0,1)
    int.phi5M ~ dunif(0,1)
    int.phiBM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -5 #0 on probability scale...?

    b.eff[1] <- 0
    b.eff[2] ~ dnorm(0, 0.001)
    
    for (t in 1:(n_occasions)) {
      eps.p[t] ~ dnorm(0, sd = sigma.p)
    }

    sigma.p ~ dexp(1)
    
    for (t in 1:(n_occasions-1)){
      epsP[t] ~ dnorm(0, sd = sigmaP)
    } 

    for (t in 2:(n_occasions-1)) {
      eps1[t] ~ dnorm(0, sd = sigma1)
    }
    
    for (t in 3:(n_occasions-1)) {
      eps2[t] ~ dnorm(0, sd = sigma2)
    }
    #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
    for (t in 4:(n_occasions-1)) { 
      eps.psiPB[t] ~ dnorm(0, sd = sigma.psiPB)
      epsPB[t] ~ dnorm(0, sd = sigmaPB)
    } #t
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      eps.psiB[t] ~ dnorm(0, sd = sigma.psiB)
      epsB[t] ~ dnorm(0, sd = sigmaB)
      epsBM[t] ~ dnorm(0, sd = sigmaB)
    } #t
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {
    eps.psiNB[t] ~ dnorm(0, sd = sigma.psiNB)
    epsNB[t] ~ dnorm(0, sd = sigmaNB)
    } #t

  #shrinkage
    sigmaP ~ dexp(1)
    sigma1 ~ dexp(1)
    sigma2 ~ dexp(1)
    sigmaPB ~ dexp(1)
    sigmaB ~ dexp(1)
    sigmaNB ~ dexp(1)
    sigma.psiPB ~ dexp(1)
    sigma.psiB ~ dexp(1)
    sigma.psiNB ~ dexp(1)
    
    #covs - psi 
    b.mass.psi ~ dnorm(0, sd = s.mass.psi)
    s.mass.psi ~ dexp(1)
    b.mass.psiB ~ dnorm(0, sd = s.mass.psiB)
    s.mass.psiB ~ dexp(1)

    #covs - phi
    b.mass.p ~ dnorm(0, sd = s.mass.p)
    s.mass.p ~ dexp(1)
    b.mass.pm ~ dnorm(0, sd = s.mass.pm)
    s.mass.pm ~ dexp(1)
    
    b.mass.1 ~ dnorm(0, sd = s.mass.1)
    s.mass.1 ~ dexp(1)
    b.mass.1m ~ dnorm(0, sd = s.mass.1m)
    s.mass.1m ~ dexp(1)
  
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    } #t likelihood fem
} #i likelihood fem
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1], pBM = pBM[i,t-1])
    } # likelihood t male
   } #likelihood i male
    
}) # mod   

##### run model ####

nim.data <- list(y = y, ym = ym, 
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], 
                      n_occasions = n_occasions, resights = res_mat, eff = eff,
                      mass_f = mass_f, mass_m = mass_m,
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiP = 0.9, int.phiPM = 0.9, int.phi1 = 0.9, int.phi1M = 0.9,
              int.phi2 = 0.9, int.phi2M = 0.9, int.phi3 = 0.9, int.phi3M = 0.9,
              int.phi4 = 0.9, int.phi4M = 0.9, int.phi5 = 0.9, int.phi5M = 0.75,
              int.phiB = 0.9, int.phiBM = 0.8, int.phiNB = 0.9, 
              mean.psi3 = qlogis(0.25), mean.psi4 = qlogis(0.6), mean.psi5 = qlogis(0.25),
              mean.psiB = qlogis(0.9), mean.psiNBM = 0.2, #prob scale for these
              mean.p1 = qlogis(0.7), mean.p2 = qlogis(0.6),
              mean.p3 = qlogis(0.6),mean.p4 = qlogis(0.6),
              mean.p5 = qlogis(0.4), mean.pB = 0.8, mean.pNB = qlogis(0.4),
              mean.p1M = qlogis(0.5), mean.p2M = qlogis(0.5), mean.p3M = qlogis(0.5), 
              mean.p4M = qlogis(0.5), 
              mean.pBM = qlogis(0.8), mean.p5M = qlogis(0.6),
              eps.p = c(rep(0, n_occasions)), #detection
              epsP = rep(0, n_occasions-1), eps1 = rep(0, n_occasions-1), eps2 = rep(0, n_occasions-1),
              epsPB = rep(0, n_occasions-1), epsB = rep(0, n_occasions-1), 
              epsNB = rep(0, n_occasions-1), epsBM = rep(0, n_occasions-1),
              eps.psiPB = rep(0, n_occasions-1), 
              eps.psiB = rep(0, n_occasions-1), eps.psiNB = rep(0, n_occasions-1),
              sigmaPB = 1, sigmaP = 1, sigmaB = 1, sigma2 = 1, sigma1 = 1, sigma.psi = 1,
              p.delB = c(0.4, 0.5, 0.75), 
              b.mass.p = 0, b.mass.pm = 0, b.mass.psi = 0, b.mass.psiB = 0,
              b.mass.1 = 0, b.mass.1m = 0, 
              z = z.init, zm = z.init.m)

### parameters
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pB', 'mean.pNB',
            'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pBM', 
            "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB',
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pB', 'int.pNB', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pBM',  
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB',
            'int.phiP', 'int.phi1', 'int.phi2', 'int.phi3', 'int.phi4', 'int.phi5', 'int.phiB', 'int.phiNB',
            'int.phiPM', 'int.phi1M', 'int.phi2M', 'int.phi3M', 'int.phi4M', 'int.phi5M', 'int.phiBM',
            'epsP', 'eps1', 'eps2','epsPB','epsB', 'epsNB', 'epsBM',
            'eps.psiPB', 'eps.psiB', 'eps.psiNB',
            'b.delB', 'p.delB','b.eff', 'eps.p', 
             'sigmaP', 'sigma1', 'sigma2', 'sigmaPB', 'sigmaB', 'sigmaNB',
            'sigma.psiPB', 'sigma.psiB', 'sigma.psiNB','sigma.p', 
            'b.mass.p', 'b.mass.1', 'b.mass.pm', 'b.mass.1m', 'b.mass.psi', 'b.mass.psiB',
            'z', 'zm', 'mu.P', 'mu.1', 'mu.2', 'mu.3', 'mu.4', 'mu.5', 'mu.B', 'mu.NB', 
            'mu.PM', 'mu.1M', 'mu.2M', 'mu.3M', 'mu.4M', 'mu.5M', 'mu.BM')

### run model
n.iter = 35000; n.chains = 3; n.burnin = 20000; nthin = 3; nAdapt = 20

start <- Sys.time()

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)


Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)

elapsed <- Sys.time()-start

# saveRDS(out, here::here('results', paste0('out_RE_WAIC.rds')))


```

```{r full}

#notes
#psi.... state in t is product of survival and breeding probability in t-1, 
#for a 3yo that survived and transitioned to become a 4yo w/ pup, the conditions in t-1 or throughout the year (yr starts w/ summer) mattered for success
# if 3yo in 2005 summer, breed to become 4yo w/ pup in 2006, then summer in 2005 would matter more than 2006
#summer months are 6:9

SSL_CJS <- nimbleCode({

# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.P + epsP[t] +
              b.albsaP*albsa[t] +
              b.AOIP*AOI[t] +
              b.upP*upwell[t] +
              b.chlaP*chla[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              b.massP*mass_f[i] 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 + b.eff[eff[t]] + eps.p[t] 
        } #t 
  
  for (t in 2:(n_occasions-1)) {
    logit(phi1[i,t]) <- mu.1 + eps1[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1*mass_f[i] 
    logit(p2[i,t]) <- mean.p2 + b.eff[eff[t]] + eps.p[t]
  }
  
  for (t in 3:(n_occasions-1)) {
    logit(phi2[i,t]) <- mu.2 + eps2[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1*mass_f[i] 
    logit(p3[i,t]) <- mean.p3 + b.eff[eff[t]] + eps.p[t]
  }
  
  #first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
      for (t in 4:(n_occasions-1)) { 
      logit(psi3[i,t]) <- mean.psi3 + eps.psiPB[t] +
              b.albsa.psi*albsa[t] +
              b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] +
              b.chla.psi*chla[t] +
              b.vwnd.psi*vwnd[t] +
              b.npgo.psi*npgo[t] +
              b.mass.psi*mass_f[i]
      logit(phi3[i,t]) <- mu.3 + epsPB[t]
      logit(p4[i,t]) <- mean.p4 + b.eff[eff[t]] + eps.p[t]
      logit(pB[i,t]) <- mean.pB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      logit(psi4[i,t]) <- mean.psi4 + eps.psiPB[t] +
              b.albsa.psi*albsa[t] +
              b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] +
              b.chla.psi*chla[t] +
              b.vwnd.psi*vwnd[t] +
              b.npgo.psi*npgo[t] +
              b.mass.psi*mass_f[i]
      logit(psiB[i,t]) <- mean.psiB + eps.psiB[t] +
              b.albsa.psiB*albsa[t] +
              b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] +
              b.chla.psiB*chla[t] +
              b.vwnd.psiB*vwnd[t] +
              b.npgo.psiB*npgo[t] +
              b.mass.psiB*mass_f[i]
      logit(phi4[i,t]) <- mu.4 + epsPB[t]
      logit(phiB[i,t]) <- mu.B + epsB[t]
      logit(p5[i,t]) <- mean.p5 + b.eff[eff[t]] + eps.p[t]
      logit(pNB[i,t]) <- mean.pNB + b.eff[eff[t]] + eps.p[t]
    } #t psi
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {  
      logit(psi5[i,t]) <- mean.psi5 + eps.psiPB[t] +
              b.albsa.psi*albsa[t] +
              b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] +
              b.chla.psi*chla[t] +
              b.vwnd.psi*vwnd[t] +
              b.npgo.psi*npgo[t] +
              b.mass.psi*mass_f[i]
      logit(psiNB[i,t]) <- mean.psiNB + eps.psiNB[t] +
              b.albsa.psiB*albsa[t] +
              b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] +
              b.chla.psiB*chla[t] +
              b.vwnd.psiB*vwnd[t] +
              b.npgo.psiB*npgo[t] +
              b.mass.psiB*mass_f[i]
      logit(phi5[i,t]) <- mu.5 + epsPB[t]
      logit(phiNB[i,t]) <- mu.NB + epsNB[t]
          } #t psi
} #i fem
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
    }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.PM + epsP[t] +
              b.albsaP*albsa[t] +
              b.AOIP*AOI[t] +
              b.upP*upwell[t] +
              b.chlaP*chla[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              b.massPM*mass_m[i] 
            logit(p1M[i,t]) <- mean.p1M + b.eff[eff[t]] + eps.p[t] 
        } #t
    
    for (t in 2:(n_occasions-1)) {
            logit(phi1M[i,t]) <- mu.1M + eps1[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1M*mass_m[i] 
            logit(p2M[i,t]) <- mean.p2M + b.eff[eff[t]] + eps.p[t]
          }
    for (t in 3:(n_occasions-1)) {
            logit(phi2M[i,t]) <- mu.2M + eps2[t] +
              b.albsa1*albsa[t] +
              b.AOI1*AOI[t] +
              b.up1*upwell[t] +
              b.chla1*chla[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.mass1M*mass_m[i] 
            logit(p3M[i,t]) <- mean.p3M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 4:(n_occasions-1)) {
            logit(phi3M[i,t]) <- mu.3M + epsPB[t] 
            logit(p4M[i,t]) <- mean.p4M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 5:(n_occasions-1)) {
            logit(phi4M[i,t]) <- mu.4M + epsPB[t] 
            logit(p5M[i,t]) <- mean.p5M + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 6:(n_occasions-1)) {
            logit(phi5M[i,t]) <- mu.5M + epsPB[t] 
            logit(pBM[i,t]) <- mean.pBM + b.eff[eff[t]] + eps.p[t]
    }
    for (t in 7:(n_occasions-1)) {
            logit(phiBM[i,t]) <- mu.BM + epsBM[t] 
    }
} #i male
  
### Priors
    #psi
    mean.psi3 <- log(int.psi3/(1-int.psi3))
    mean.psi4 <- log(int.psi4/(1-int.psi4))
    mean.psi5 <- log(int.psi5/(1-int.psi5))
    mean.psiB <- log(int.psiB/(1-int.psiB))
    mean.psiNB <- log(int.psiNB/(1-int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    #p
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pB <- log(int.pB/(1 - int.pB))
    mean.pNB <- log(int.pNB/(1 - int.pNB))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pBM <- log(int.pBM/(1 - int.pBM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pB ~ dunif(0,1)
    int.pNB ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pBM ~ dunif(0,1)
    #phi
    mu.P <- log(int.phiP/(1 - int.phiP))
    mu.1 <- log(int.phi1/(1 - int.phi1))
    mu.2 <- log(int.phi2/(1 - int.phi2))
    mu.3 <- log(int.phi3/(1 - int.phi3))
    mu.4 <- log(int.phi4/(1 - int.phi4))
    mu.5 <- log(int.phi5/(1 - int.phi5))
    mu.B <- log(int.phiB/(1 - int.phiB))
    mu.NB <- log(int.phiNB/(1 - int.phiNB))
    mu.PM <- log(int.phiPM/(1 - int.phiPM))
    mu.1M <- log(int.phi1M/(1 - int.phi1M))
    mu.2M <- log(int.phi2M/(1 - int.phi2M))
    mu.3M <- log(int.phi3M/(1 - int.phi3M))
    mu.4M <- log(int.phi4M/(1 - int.phi4M))
    mu.5M <- log(int.phi5M/(1 - int.phi5M))
    mu.BM <- log(int.phiBM/(1 - int.phiBM))
    int.phiP ~ dunif(0,1)
    int.phi1 ~ dunif(0,1)
    int.phi2 ~ dunif(0,1)
    int.phi3 ~ dunif(0,1)
    int.phi4 ~ dunif(0,1)
    int.phi5 ~ dunif(0,1)
    int.phiB ~ dunif(0,1)
    int.phiNB ~ dunif(0,1)
    int.phiPM ~ dunif(0,1)
    int.phi1M ~ dunif(0,1)
    int.phi2M ~ dunif(0,1)
    int.phi3M ~ dunif(0,1)
    int.phi4M ~ dunif(0,1)
    int.phi5M ~ dunif(0,1)
    int.phiBM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -5 #0 on probability scale...? check help

    b.eff[1] <- 0
    b.eff[2] ~ dnorm(0, 0.001)
    
    for (t in 1:(n_occasions)) {
      eps.p[t] ~ dnorm(0, sd = sigma.p)
    }

    sigma.p ~ dexp(1)
    
    for (t in 1:(n_occasions-1)){
      epsP[t] ~ dnorm(0, sd = sigmaP)
      phiP.prob[t] <- 1/(1+exp(-(mu.P + epsP[t] + b.vwndP*vwnd[t] + b.npgoP*npgo[t] +
              b.albsaP*albsa[t] + b.AOIP*AOI[t] + b.upP*upwell[t] + b.chlaP*chla[t])))
      phiPM.prob[t] <- 1/(1+exp(-(mu.PM + epsP[t] + b.vwndP*vwnd[t] + b.npgoP*npgo[t] +
              b.albsaP*albsa[t] + b.AOIP*AOI[t] + b.upP*upwell[t] + b.chlaP*chla[t])))
          } 

    for (t in 2:(n_occasions-1)) {
      eps1[t] ~ dnorm(0, sd = sigma1)
      phi1.prob[t] <- 1/(1+exp(-(mu.1 + eps1[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
      phi1M.prob[t] <- 1/(1+exp(-(mu.1M + eps1[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
    }
    
    for (t in 3:(n_occasions-1)) {
      eps2[t] ~ dnorm(0, sd = sigma2)
      phi2.prob[t] <- 1/(1+exp(-(mu.2 + eps2[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
      phi2M.prob[t] <- 1/(1+exp(-(mu.2M + eps2[t] + b.vwnd1*vwnd[t] + b.npgo1*npgo[t] +
              b.albsa1*albsa[t] + b.AOI1*AOI[t] + b.up1*upwell[t] + b.chla1*chla[t])))
    }
#first cohort branded in 2000, turn 1 in 2001, turn 3 in 2003, and as 3 yo's could transition
    for (t in 4:(n_occasions-1)) { 
      eps.psiPB[t] ~ dnorm(0, sd = sigma.psiPB)
      epsPB[t] ~ dnorm(0, sd = sigmaPB)
      phi3.prob[t] <- 1/(1+exp(-(mu.3 + epsPB[t])))
      phi3M.prob[t] <- 1/(1+exp(-(mu.3M + epsPB[t])))
      psi3.prob[t] <- 1/(1+exp(-(mean.psi3 + eps.psiPB[t] + b.albsa.psi*albsa[t] + b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] + b.chla.psi*chla[t] + b.vwnd.psi*vwnd[t] + b.npgo.psi*npgo[t])))
    } #t
    
    #first cohort branded in 2000 could have been breeders in 2004 and could breed again the next year
    for (t in 5:(n_occasions-1)) {
      eps.psiB[t] ~ dnorm(0, sd = sigma.psiB)
      epsB[t] ~ dnorm(0, sd = sigmaB)
      epsBM[t] ~ dnorm(0, sd = sigmaB)
      phi4.prob[t] <- 1/(1+exp(-(mu.4 + epsPB[t])))
      phi4M.prob[t] <- 1/(1+exp(-(mu.4M + epsPB[t])))
      psi4.prob[t] <- 1/(1+exp(-(mean.psi4 + eps.psiPB[t] + b.albsa.psi*albsa[t] + b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] + b.chla.psi*chla[t] + b.vwnd.psi*vwnd[t] + b.npgo.psi*npgo[t])))
      psiB.prob[t] <- 1/(1+exp(-(mean.psiB + eps.psiB[t] + b.albsa.psiB*albsa[t] + b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] + b.chla.psiB*chla[t] + b.vwnd.psiB*vwnd[t] + b.npgo.psiB*npgo[t])))
      phiB.prob[t] <- 1/(1+exp(-(mu.B + epsB[t])))
      phiBM.prob[t] <- 1/(1+exp(-(mu.BM + epsBM[t])))
    } #t
    
    #first cohort would be turning 5 in 2005 (t==6) and only 5+ can be transitioning to NB
    for (t in 6:(n_occasions-1)) {
    eps.psiNB[t] ~ dnorm(0, sd = sigma.psiNB)
    epsNB[t] ~ dnorm(0, sd = sigmaNB)
    
      phi5.prob[t] <- 1/(1+exp(-(mu.5 + epsPB[t])))
      phi5M.prob[t] <- 1/(1+exp(-(mu.5M + epsPB[t])))
      psi5.prob[t] <- 1/(1+exp(-(mean.psi5 + eps.psiPB[t] + b.albsa.psi*albsa[t] + b.AOI.psi*AOI[t] +
              b.up.psi*upwell[t] + b.chla.psi*chla[t] + b.vwnd.psi*vwnd[t] + b.npgo.psi*npgo[t])))
      psiNB.prob[t] <- 1/(1+exp(-(mean.psiNB + eps.psiNB[t] + b.albsa.psiB*albsa[t] + b.AOI.psiB*AOI[t] +
              b.up.psiB*upwell[t] + b.chla.psiB*chla[t] + b.vwnd.psiB*vwnd[t] + b.npgo.psiB*npgo[t])))
      phiNB.prob[t] <- 1/(1+exp(-(mu.NB + epsNB[t])))

    } #t

  #shrinkage
    sigmaP ~ dexp(1)
    sigma1 ~ dexp(1)
    sigma2 ~ dexp(1)
    sigmaPB ~ dexp(1)
    sigmaB ~ dexp(1)
    sigmaNB ~ dexp(1)
    sigma.psiPB ~ dexp(1)
    sigma.psiB ~ dexp(1)
    sigma.psiNB ~ dexp(1)
    
    #covs - psi 
    b.mass.psi ~ dnorm(0, sd = s.mass.psi)
    s.mass.psi ~ dexp(1)
    b.mass.psiB ~ dnorm(0, sd = s.mass.psiB)
    s.mass.psiB ~ dexp(1)
    
    b.npgo.psi ~ dnorm(0, sd = s.npgo.psi)
    s.npgo.psi ~ dexp(1)
    b.npgo.psiB ~ dnorm(0, sd = s.npgo.psiB)
    s.npgo.psiB ~ dexp(1)
    
    b.albsa.psi ~ dnorm(0, sd = s.albsa.psi)
    s.albsa.psi ~ dexp(1)
    b.albsa.psiB ~ dnorm(0, sd = s.albsa.psiB)
    s.albsa.psiB ~ dexp(1)
    
    b.vwnd.psi ~ dnorm(0, sd = s.vwnd.psi)
    s.vwnd.psi ~ dexp(1)
    b.vwnd.psiB ~ dnorm(0, sd = s.vwnd.psiB)
    s.vwnd.psiB ~ dexp(1)

    b.chla.psi ~ dnorm(0, sd = s.chla.psi)
    s.chla.psi ~ dexp(1)
    b.chla.psiB ~ dnorm(0, sd = s.chla.psiB)
    s.chla.psiB ~ dexp(1)
    
    b.up.psi ~ dnorm(0, sd = s.up.psi)
    s.up.psi ~ dexp(1)
    b.up.psiB ~ dnorm(0, sd = s.up.psiB)
    s.up.psiB ~ dexp(1)
    
    b.AOI.psi ~ dnorm(0, sd = s.AOI.psi)
    s.AOI.psi ~ dexp(1)
    b.AOI.psiB ~ dnorm(0, sd = s.AOI.psiB)
    s.AOI.psiB ~ dexp(1)

    #covs - phi
    b.massP ~ dnorm(0, sd = s.massP)
    s.massP ~ dexp(1)
    b.massPM ~ dnorm(0, sd = s.massPM)
    s.massPM ~ dexp(1)
    b.mass1 ~ dnorm(0, sd = s.mass1)
    s.mass1 ~ dexp(1)
    b.mass1M ~ dnorm(0, sd = s.mass1M)
    s.mass1M ~ dexp(1)
    
    b.chlaP ~ dnorm(0, sd = s.chlaP)
    s.chlaP ~ dexp(1)
    b.chla1 ~ dnorm(0, sd = s.chla1)
    s.chla1 ~ dexp(1)

    b.upP ~ dnorm(0, sd = s.upP)
    s.upP ~ dexp(1)
    b.up1 ~ dnorm(0, sd = s.up1)
    s.up1 ~ dexp(1)

    b.npgoP ~ dnorm(0, pow(s.npgoP,-2))
    s.npgoP ~ dexp(1)
    b.npgo1 ~ dnorm(0, pow(s.npgo1,-2))
    s.npgo1 ~ dexp(1)

    b.albsaP ~ dnorm(0, pow(s.albsaP,-2))
    s.albsaP ~ dexp(1)
    b.albsa1 ~ dnorm(0, pow(s.albsa1,-2))
    s.albsa1 ~ dexp(1)

    b.AOIP ~ dnorm(0, pow(s.AOIP,-2))
    s.AOIP ~ dexp(1)
    b.AOI1 ~ dnorm(0, pow(s.AOI1,-2))
    s.AOI1 ~ dexp(1)

    b.vwndP ~ dnorm(0, pow(s.vwndP,-2))
    s.vwndP ~ dexp(1)
    b.vwnd1 ~ dnorm(0, pow(s.vwnd1,-2))
    s.vwnd1 ~ dexp(1)
    
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    } #t likelihood fem
} #i likelihood fem
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1], pBM = pBM[i,t-1])
    } # likelihood t male
   } #likelihood i male
    
}) # mod   

##### run model ####

nim.data <- list(y = y, ym = ym, 
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], n_occasions = n_occasions, 
                      resights = res_mat, eff = eff, mass_f = mass_f, mass_m = mass_m,
                      chla = chla, npgo = npgo, albsa = albsa, vwnd = vwnd, AOI = AOI, upwell = upwell, 
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiP = 0.9, int.phiPM = 0.9, int.phi1 = 0.9, int.phi1M = 0.9,
              int.phi2 = 0.9, int.phi2M = 0.9, int.phi3 = 0.9, int.phi3M = 0.9,
              int.phi4 = 0.9, int.phi4M = 0.9, int.phi5 = 0.9, int.phi5M = 0.75,
              int.phiB = 0.9, int.phiBM = 0.8, int.phiNB = 0.9, 
              mean.psi3 = qlogis(0.25), mean.psi4 = qlogis(0.6), mean.psi5 = qlogis(0.25),
              mean.psiB = qlogis(0.9), 
              mean.p1 = qlogis(0.7), mean.p2 = qlogis(0.6),
              mean.p3 = qlogis(0.6),mean.p4 = qlogis(0.6),
              mean.p5 = qlogis(0.4), mean.pB = 0.8, mean.pNB = qlogis(0.4),
              mean.p1M = qlogis(0.5), mean.p2M = qlogis(0.5), mean.p3M = qlogis(0.5), 
              mean.p4M = qlogis(0.5), mean.pBM = qlogis(0.8), mean.p5M = qlogis(0.6),
              eps.p = c(rep(0, n_occasions)), #detection
              epsP = rep(0, n_occasions-1), eps1 = rep(0, n_occasions-1), eps2 = rep(0, n_occasions-1),
              epsPB = rep(0, n_occasions-1), epsB = rep(0, n_occasions-1), 
              epsNB = rep(0, n_occasions-1), epsBM = rep(0, n_occasions-1),
              eps.psiPB = rep(0, n_occasions-1), 
              eps.psiB = rep(0, n_occasions-1), eps.psiNB = rep(0, n_occasions-1),
              sigmaPB = 1, sigmaP = 1, sigmaB = 1, sigma2 = 1, sigma1 = 1, 
              p.delB = c(0.4, 0.5, 0.75), 
              b.massP = 0, b.massPM = 0, b.mass.psi = 0, b.mass.psiB = 0,
              b.mass1 = 0, b.mass1M = 0, 
              #phi betas
              b.chlaP = 0, b.chla1 = 0,
              b.albsaP = 0, b.albsa1 = 0,
              b.upP = 0, b.up1 = 0,
              b.vwndP = 0, b.vwnd1 = 0,
              b.AOIP = 0, b.AOI1 = 0,
              b.npgoP = 0, b.npgo1 = 0,
              #psi betas
              b.albsa.psi = 0, b.albsa.psiB = 0,
              b.chla.psi = 0, b.chla.psiB = 0, 
              b.AOI.psi = 0, b.AOI.psiB = 0,
              b.up.psi = 0, b.up.psiB = 0,
              b.npgo.psi = 0, b.npgo.psiB = 0,
              b.vwnd.psi = 0, b.vwnd.psiB = 0,
              z = z.init, zm = z.init.m)

### parameters
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pB', 'mean.pNB',
            'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pBM', 
            "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB',
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pB', 'int.pNB', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pBM',  
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB',
            'int.phiP', 'int.phi1', 'int.phi2', 'int.phi3', 'int.phi4', 'int.phi5', 
            'int.phiB', 'int.phiNB',
            'int.phiPM', 'int.phi1M', 'int.phi2M', 'int.phi3M', 'int.phi4M', 'int.phi5M', 'int.phiBM',
            'epsP', 'eps1', 'eps2', 'epsPB','epsB', 'epsNB', 'epsBM',
            'eps.psiPB', 'eps.psiB', 'eps.psiNB',
            'b.delB', 'p.delB', 'b.eff', 'eps.p', 
             'sigmaP', 'sigma1', 'sigma2', 'sigmaPB', 'sigmaB', 'sigmaNB',
            'sigma.psiPB', 'sigma.psiB', 'sigma.psiNB', 'sigma.p', 
            'nat_all', 'nat4', 'nat5', 'nat6plus',
            #phi cov betas
                'b.AOIP', 'b.AOI1',
                'b.upP', 'b.up1',
                'b.chlaP', 'b.chla1',
                'b.albsaP', 'b.albsa1',
                'b.npgoP', 'b.npgo1',
                'b.vwndP', 'b.vwnd1',
            #psi cov betas 
                  'b.chla.psi', 'b.chla.psiB',
                  'b.vwnd.psi', 'b.vwnd.psiB',
                  'b.up.psi', 'b.up.psiB',
                  'b.AOI.psi', 'b.AOI.psiB',
                  'b.albsa.psi', 'b.albsa.psiB',
                  'b.npgo.psi', 'b.npgo.psiB',
            'b.massP', 'b.mass1', 'b.massPM', 'b.mass1M', 'b.mass.psi', 'b.mass.psiB',
            'z', 'zm', 
            'phiP.prob', 'phi1.prob', 'phi2.prob', 'phi3.prob', 'phi4.prob', 'phi5.prob',
            'phiPM.prob', 'phi1M.prob', 'phi2M.prob', 'phi3M.prob', 'phi4M.prob', 'phi5M.prob',
            'phiB.prob', 'phiNB.prob', 'phiBM.prob',
            'psi3.prob', 'psi4.prob', 'psi5.prob', 'psiB.prob', 'psiNB.prob',
            'mu.P', 'mu.1', 'mu.2', 'mu.3', 'mu.4', 'mu.5', 'mu.B', 'mu.NB', 
            'mu.PM', 'mu.1M', 'mu.2M', 'mu.3M', 'mu.4M', 'mu.5M', 'mu.BM')

### run model
n.iter = 45000; n.chains = 3; n.burnin = 25000; nthin = 2; nAdapt = 10

# start <- Sys.time()

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)


Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)

elapsed <- Sys.time()-start

# saveRDS(out, here::here('results', paste0('out_full_east_', seas, '.rds')))

# rhats <- gelman.diag(out, multivariate=F, autoburnin=F)
# max_rhat <- max(rhats$psrf[,1], na.rm = T)


```


##### West models

```{r load data WALEU and CALEU}

#capture histories
ch_fem <- read.csv(here::here('data', 'ProcData', 'ch_fem_WEST.csv'), 
                   header = T, stringsAsFactors = F) %>%
  transform(Sex = ifelse(Sex == 'FALSE', 'F', NA))
ch_male <- read.csv(here::here('data', 'ProcData', 'ch_m_WEST.csv'), 
                    header = T, stringsAsFactors = F)

#number of times seen per year
resights <- read.csv(here::here('data','ProcData', 'num_resight_WEST.csv'), 
                     header = T, stringsAsFactors = F) 

# n_ind <- dim(ch_wide)[1]
n_occasions <- dim(ch_fem)[2]-7 #subtract id columns
res_mat <- as.matrix(resights[,2:9]) #pups are in, 1: 1-2 resights, 2: 3-8, 3: 9+, 4: ND

mass_f_waleu <- ch_fem$Mass_std
mass_m_waleu <- ch_male$Mass_std

```

```{r waleu ocean}

#adjusted year is the phi period (adj year == 1 is pups born in 2000 surviving to 2001)
#fall and summer adj_year 0 == NA (would be Sept-Dec 1999)
#spring and winter adj_year 18 == NA (would be Jan-May 2018, for pups born in 2017)
#if want to study lag time (pups born in June 2000 strongly affected by mom's forage availability in winter 1999-2000 rather than first solo foraging winter 2000-2001), get June-Dec 1999 data exclude 1999 and 2019, just want up through May/Spring of 2018 for pups born in 2017

#range-wide
ocean_SSL <- read.csv(here::here('data', 'ProcData', 'ocean_all_adj_west.csv'), 
                      stringsAsFactors = F, header = T) %>%
  filter(adj_year > 0 & adj_year < 19) 

#adj_year 1 = survival from 2000 to 2001; 18 = survival from 2017 to 2018
#adj_year 12 = survival from 2011 to 2012; 18 = from 2017 to 2018
start <- 12; stop <- 18
seas <- 'NB'
seas <- 'spr'
seas <- 'sum'
seas <- 'fall'
seas <- 'win'

albsa <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$ALBSA_', seas, '[', start,':', stop,']')))))
PDO <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$PDO_', seas, '[', start,':', stop,']')))))
AOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$AOI_', seas, '[', start,':', stop,']')))))
upwell <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$upwell_', seas, '[', start,':', stop,']')))))
chla <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$chla_', seas, '[', start,':', stop,']')))))
sst <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$sst_', seas, '[', start,':', stop,']')))))
vwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$vwnd_', seas, '[', start,':', stop,']')))))
curl <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$curl_', seas, '[', start,':', stop,']')))))
prod <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$prod_', seas, '[', start,':', stop,']')))))
scal <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$scalar_', seas, '[', start,':', stop,']')))))
#highly correlated with others
# NOI <- eval(parse(text = paste0('ocean_SSL$NOI_', seas, '[', start,':', stop,']')))
# NPI <- eval(parse(text = paste0('ocean_SSL$NPI_', seas, '[', start,':', stop,']')))
npgo <- eval(parse(text = paste0('ocean_SSL$NPGO_', seas, '[', start,':', stop,']')))

# fix NA values
albsa[is.na(albsa)] <- 0
PDO[is.na(PDO)] <- 0
# MEI[is.na(MEI)] <- 0
AOI[is.na(AOI)] <- 0
upwell[is.na(upwell)] <- 0
npgo[is.na(npgo)] <- 0
chla[is.na(chla)] <- 0
sst[is.na(sst)] <- 0
vwnd[is.na(vwnd)] <- 0
# uwnd[is.na(uwnd)] <- 0
prod[is.na(prod)] <- 0
curl[is.na(curl)] <- 0
scal[is.na(scal)] <- 0

### Correlations
# library(Hmisc)
# 
# ## single season - all variables
# flattenCorrMatrix <- function(cormat, pmat) {
#   ut <- upper.tri(cormat)
#   data.frame(
#     row = rownames(cormat)[row(cormat)[ut]],
#     column = rownames(cormat)[col(cormat)[ut]],
#     cor  =(cormat)[ut],
#     p = pmat[ut]
#   )
# }
# cor <- rcorr(as.matrix(ocean_SSL[,grepl('NB', colnames(ocean_SSL))]))
# cor_vals <- flattenCorrMatrix(cor$r, cor$P) %>% arrange(cor)
# corrplot(cor$r, type = "lower", order = "original", p.mat = cor$P,
#          insig = "blank", sig.level = 0.01, tl.col = "black", tl.cex = .9, number.cex = .2)

#NB: PDO/MEI, PDO/NOI, MEI/NOI/NPI, albsa/vwnd, albsa/NPI

#spring: PDO/NOI, PDO/NPI, upwell/NPI, vwnd/albsa, uwnd/NOI, curl/NPGO

#summer: PDO/MEI, PDO/NPGO, AOI/NPI, albsa/chla

#fall: PDO/NOI, PDO/MEI, NOI/MEI, ssh/NPI, temp/so

#winter: PDO/MEI, PDO/NOI, MEI/NPI, vwnd/albsa, albsa/MEI, prod/scalar

```

```{r fc inits waleu}

##female (same as range-wide)
#first capture
get.first <- function(x) min(which(x != 11)) #include animals branded as non-pups
fc <- apply(ch_fem[,-c(1:7)], 1, get.first)

ch <- ch_fem[,-c(1:7)]
for (i in 1:dim(ch)[1]) {
  if(fc[i] > 1) {ch[i, 1:(fc[i]-1)] <- NA }
}

y <- as.matrix(ch)

cjs.me.init <- function(ch, fc){
  inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
  for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){   
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 7} #all 4yrs are (pre-)breeders
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 8} #all 5yrs are breeders
      if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 9} #all 6yrs+ are breeders
  } #i
  return(inits)
}

z.init = as.matrix(cjs.me.init(ch, fc))
#if giving latent z.st as data, change z.init in these ways:
z.init[which(y < 5)] <- NA #all obs pre-breeders are known state, so don't estimate
z.init[which(y == 6)] <- NA  #all obs w pup are known state, don't estimate
z.init[which(y == 8)] <- NA
z.init[which(y == 10)] <- NA

#want NAs where we're estimating, minus ==1 since that is set in the model
z.st <- as.matrix(ch)
z.st[which(z.st == 1)] <- NA
z.st[which(z.st == 11)] <- NA #all ND are unknown state
z.st[which(z.st == 5)] <- NA  #all obs w/o pup are unknown state, otherwise state can be obs equivalent
z.st[which(z.st == 7)] <- NA
z.st[which(z.st == 9)] <- NA
z.st[which(z.st == 6)] <- 7 #obs of 6 is state 7
z.st[which(z.st == 10)] <- 9 #obs of 10 is state 9; obs of 8 is state 8 leave as is

#male (different than above)
#first capture
get.first.m <- function(x) min(which(x != 8)) #include animals branded as non-pups
fc_m <- apply(ch_male[,-c(1:7)], 1, get.first.m)

ch_m <- ch_male[,-c(1:7)]
for (i in 1:dim(ch_m)[1]) {
  if(fc_m[i] > 1) {ch_m[i, 1:(fc_m[i]-1)] <- NA } #everything NA before first capture
}

ym <- as.matrix(ch_m)

cjs.me.init.m <- function(ch, fc) {
    inits <- ch    #initialize with observations up until states diverge from observations (4yr olds)
    for(i in 1:dim(ch)[1]) { 
    inits[i,fc[i]] <- NA #pups at release
      if(n_occasions-fc[i]>=1){    
        inits[i,(fc[i] + 1)] <- 2} #1 yr old
      if(n_occasions-fc[i]>=2){
        inits[i,(fc[i] + 2)] <- 3}  #2 yr old
      if(n_occasions-fc[i]>=3){
        inits[i,(fc[i] + 3)] <- 4} #3 yr old
      if(n_occasions-fc[i]>=4) {
        inits[i,(fc[i] + 4)] <- 5} #4 yr old
      if(n_occasions-fc[i]>=5) {
        inits[i,(fc[i] + 5)] <- 6} #5 yr olds
     if(n_occasions-fc[i]>=6) {
        inits[i,((fc[i] + 6):n_occasions)] <- 7} #start all breeding adult age animals at 7
  } #i
  return(inits)
}

z.init.m = as.matrix(cjs.me.init.m(ch_m, fc_m))
#if giving latent z.st as data, change z.init in these ways:
z.init.m[which(ym == 1)] <- NA
z.init.m[which(ym == 2)] <- NA
z.init.m[which(ym == 3)] <- NA
z.init.m[which(ym == 4)] <- NA
z.init.m[which(ym == 5)] <- NA
z.init.m[which(ym == 6)] <- NA
z.init.m[which(ym == 7)] <- NA

#known latent state
z.st.m <- as.matrix(ch_m)

#need to set instances where males were seen as non-breeder between breeding years as a breeder since we're assuming territorial males stay that way, with known state of 7, so need a get first and get last for breeding
get.first.B <- function(x) min(which(x == 7))
fb <- apply(ch_male[,-c(1:7)], 1, get.first.B) #inf warnings for animals never seen as a breeder
get.last.B <- function(x) max(which(x == 7)) 
lb <- apply(ch_male[,-c(1:7)], 1, get.last.B)

#want NAs where we're estimating, minus == 1 since that is set in the model
z.st.m[which(z.st.m == 1)] <- NA
z.st.m[which(z.st.m == 8)] <- NA #not detected

#breeder between breeding observations
for (i in 1:dim(z.st.m)[1]) {
  if (fb[i] != Inf) {
    z.st.m[i, (fb[i]:lb[i])] <- 7
  }
}

z.init.m[which(z.st.m == 7)] <- NA #need to get the between-breeder observations for inits too, not just all == 7


```

```{r null waleu}

SSL_CJS <- nimbleCode({
  
# Priors and constraints
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.phi[1]
            logit(phi1[i,t]) <- mu.phi[2]
            logit(phi2[i,t]) <- mu.phi[3]
            logit(phi3[i,t]) <- mu.phi[4]
            logit(phi4[i,t]) <- mu.phi[5]
            logit(phi5[i,t]) <- mu.phi[6]
            logit(phiB[i,t]) <- mu.A
            logit(phiNB[i,t]) <- mu.A
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 #+ b.eff[eff[t]]
            logit(p2[i,t]) <- mean.p2 #+ b.eff[eff[t]]
            logit(p3[i,t]) <- mean.p3 #+ b.eff[eff[t]]
            logit(p4[i,t]) <- mean.p4 #+ b.eff[eff[t]]
            logit(p5[i,t]) <- mean.p5 #+ b.eff[eff[t]]
            logit(pB[i,t]) <- mean.pA #+ b.eff[eff[t]]
            logit(pNB[i,t]) <- mean.pA #+ b.eff[eff[t]]
            psi3[i,t] <- int.psi3
            psi4[i,t] <- int.psi4
            psi5[i,t] <- int.psi5
            psiB[i,t] <- int.psiB
            psiNB[i,t] <- int.psiNB
        }
}
  
   for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
   }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.phiM[1]
            logit(phi1M[i,t]) <- mu.phiM[2]
            logit(phi2M[i,t]) <- mu.phiM[3]
            logit(phi3M[i,t]) <- mu.phiM[4]
            logit(phi4M[i,t]) <- mu.phiM[5]
            logit(phi5M[i,t]) <- mu.phiM[6]
            logit(phiBM[i,t]) <- mu.AM
            logit(p1M[i,t]) <- mean.p1M #+ b.eff[eff[t]]
            logit(p2M[i,t]) <- mean.p2M #+ b.eff[eff[t]]
            logit(p3M[i,t]) <- mean.p3M #+ b.eff[eff[t]]
            logit(p4M[i,t]) <- mean.p4M #+ b.eff[eff[t]]
            logit(p5M[i,t]) <- mean.p5M #+ b.eff[eff[t]]
            logit(pBM[i,t]) <- mean.pAM #+ b.eff[eff[t]]
        }
  }
  
  ## survival
  #females
  mu.phi[1:6] ~ dmnorm(zeros[1:6], P[1:6,1:6])

  for(i in 1:6) zeros[i] <- 0 # or just read this in as data
  P[1:6,1:6] <- tau.phi*Q[1:6,1:6]
  tau.phi <- 1/(sigma.phi*sigma.phi)
  sigma.phi ~ dexp(1) # try different rates here for the exp prior 

  #males
  mu.phiM[1:6] ~ dmnorm(zeros.m[1:6], P.m[1:6,1:6])

  for(i in 1:6) zeros.m[i] <- 0 
  P.m[1:6,1:6] <- tau.phiM*Q[1:6,1:6]
  tau.phiM <- 1/(sigma.phiM*sigma.phiM)
  sigma.phiM ~ dexp(1)
   
    mu.A <- log(int.phiA/(1 - int.phiA))
    mu.AM <- log(int.phiAM/(1 - int.phiAM))
    int.phiA ~ dunif(0,1)
    int.phiAM ~ dunif(0,1)
  
  #breeding
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    
  #detection
    mean.p1 <- log(int.p1/(1 - int.p1))
    mean.p2 <- log(int.p2/(1 - int.p2))
    mean.p3 <- log(int.p3/(1 - int.p3))
    mean.p4 <- log(int.p4/(1 - int.p4))
    mean.p5 <- log(int.p5/(1 - int.p5))
    mean.pA <- log(int.pA/(1 - int.pA))
    mean.p1M <- log(int.p1M/(1 - int.p1M))
    mean.p2M <- log(int.p2M/(1 - int.p2M))
    mean.p3M <- log(int.p3M/(1 - int.p3M))
    mean.p4M <- log(int.p4M/(1 - int.p4M))
    mean.p5M <- log(int.p5M/(1 - int.p5M))
    mean.pAM <- log(int.pAM/(1 - int.pAM))
    int.p1 ~ dunif(0,1)
    int.p2 ~ dunif(0,1)
    int.p3 ~ dunif(0,1)
    int.p4 ~ dunif(0,1)
    int.p5 ~ dunif(0,1)
    int.pA ~ dunif(0,1)
    int.p1M ~ dunif(0,1)
    int.p2M ~ dunif(0,1)
    int.p3M ~ dunif(0,1)
    int.p4M ~ dunif(0,1)
    int.p5M ~ dunif(0,1)
    int.pAM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -2 #0 on probability scale

    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture
    # z_new[i, fc[i]:fc[i]] <- 1

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
      #predictions
      # z_new[i,t] ~ dcat(state_probs_new[i,t-1,1:12])
      # y_new[i,t] ~ dcat(event_probs_new[i,t,1:11])
      
      #count yearlings and breeders
      # yearlings[t] <- sum(z[1:n_fem,t]==2)
      # yearlingsy[t] <- sum(y[1:n_fem,t]==2)
      # breeders[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)
      # breedersy[t] <- sum(y[1:n_fem,t] == 6 | y[1:n_fem,t] == 8 | y[1:n_fem,t] == 10)
      # 
      # yearlings_pred[t] <- sum(z_new[1:n_fem,t]==2)
      # yearlings_predy[t] <- sum(y_new[1:n_fem,t]==2)
      # breeders_pred[t] <- sum(z_new[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)
      # breeders_predy[t] <- sum(y_new[1:n_fem,t] == 6 | y_new[1:n_fem,t] == 8 | 
      #                            y_new[1:n_fem,t] == 10)
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    
    # state_probs_new[i,t-1,1:12] <- getPHI_f(z = z_new[i,t-1], 
    #                                   phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
    #                                   phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
    #                                   phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
    #                                   psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
    #                                   psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    # 
    # event_probs_new[i,t,1:11] <- getP_f(z = z_new[i,t], 
    #                                 p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
    #                                 p4 = p4[i,t-1], p5 = p5[i,t-1],
    #                                 pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    
    
    } #t females
} #i females
    
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
    # zm_new[i, fc_m[i]:fc_m[i]] <- 1
    
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    # zm_new[i,t] ~ dcat(state_probs_m_new[i,t-1,1:8])
    # ym_new[i,t] ~ dcat(event_probs_m_new[i,t,1:8])
    
      #count yearlings and breeders
      # yearlingsM[t] <- sum(zm[1:n_m,t]==2)
      # yearlingsMy[t] <- sum(ym[1:n_m,t]==2)
      # 
      # yearlingsM_pred[t] <- sum(zm_new[1:n_m,t]==2)
      # yearlingsM_predy[t] <- sum(ym_new[1:n_m,t]==2)
      # 
      # twosM[t] <- sum(zm[1:n_m,t]==3)
      # twosMy[t] <- sum(ym[1:n_m,t]==3)
      # 
      # twosM_pred[t] <- sum(zm_new[1:n_m,t]==3)
      # twosM_predy[t] <- sum(ym_new[1:n_m,t]==3)
    
      # dev <- -2*logdensity.cat(y[i,t,], z[i,t]p[i,t])
      # dev_new <- -2*logdensity.cat(y_new[i,t,], z_new[i,t]p[i,t])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1],
                                    pBM = pBM[i,t-1])
    
    # state_probs_m_new[i,t-1,1:8] <- getPHI_m(z = zm_new[i,t-1], 
    #                                   phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
    #                                   phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
    #                                   phiBM = phiBM[i,t-1])
    # event_probs_m_new[i,t,1:8] <- getP_m(z = zm_new[i,t], 
    #                                 p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
    #                                 p4M = p4M[i,t-1], p5M = p5M[i,t-1],
    #                                 pBM = pBM[i,t-1])
    } #t
   } #i
    
}) # mod   

 
#data
nim.data <- list(y = y, ym = ym, 
                Q = matrix(c(1,-2,1,0,0,0,
                             -2,5,-4,1,0,0,
                             1,-4,6,-4,1,0,
                             0,1,-4,6,-4,1,
                             0,0,1,-4,5,-2,
                             0,0,0,1,-2,1), ncol = 6, nrow = 6, byrow = T),
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], n_occasions = n_occasions,
                      resights = res_mat, 
                      # eff = eff,
                      fc = fc, fc_m = fc_m)

inits <- list(int.phiA = 0.9, int.phiAM = 0.9,
              mean.psi3 = 0.05, mean.psi4 = 0.3, mean.psi5 = 0.15, 
              mean.psiB = 0.9, mean.psiNB = 0.20,
              mean.pAM = 0.8, mean.p5M = 0.6,
              mu.phi = rep(qlogis(0.9),6), mu.phiM = rep(qlogis(0.9),6),
  z = z.init, zm = z.init.m)

### parameters
params <- c('int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5', 'int.pA', 
            'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pAM', 
            "int.psi3", 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB', 
            'nat_all', 'nat4', 'nat5', 'nat6plus', 'int.phiA', 'int.phiAM', 
            # 'yearlings', 'yearlings_pred',  'yearlingsy', 'yearlings_predy',
            # 'breeders', 'breeders_pred', 'breedersy', 'breeders_predy',
            # 'yearlingsM', 'yearlingsMy', 'yearlingsM_pred', 'yearlingsM_predy',
            # 'twosM', 'twosMy', 'twosM_predy', 'twosM_pred',
            'b.delB', 'p.delB', #'b.delBM', 'p.delBM', 
            'mu.phi', 'mu.phiM', 'tau.phiM',  'sigma.phiM', 'tau.phi',  'sigma.phi',
            'z', 'zm', #'y_new', 'ym_new', #monitor z for WAIC, y and y_new for bayesian p
            'mu.A', 'mu.AM')

### run model
# n.iter = 700; n.chains = 3; n.burnin = 100; nthin = 1; nAdapt = 10
# n.iter = 15000; n.chains = 3; n.burnin = 8000; nthin = 1; nAdapt = 10
n.iter = 10000; n.chains = 3; n.burnin = 5000; nthin = 1; nAdapt = 10


start <- Sys.time()

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

# Rmodel$y #returns data
# Rmodel$simulate('z[1, 4]')
# Rmodel$calculate('mean.p1')

# Rmodel$calculate(c('y', 'y_new'))
# Rmodel$simulate(c('y'))
# Rmodel$y
# 
# Rmodel$logProb_y
# Rmodel$logProb_y_new

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)

# CV_out <- runCrossValidate(conf, 4, MCMCcontrol = list(niter = n.iter, nburnin = n.burnin))

Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
# Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)

# st2<-Sys.time()
out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE,
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)

# elapsed <- Sys.time()-start

# saveRDS(out, here::here('results', 'out_null_west.rds'))

#diagnostics

all_pars <- colnames(out$samples$chain1)
noZ <- all_pars[which(!grepl('z', all_pars))]
rhats <- gelman.diag(out$samples[,noZ], multivariate=F, autoburnin=F)
# traceplot(out$samples[,noZ[1:37]])
 
# max_rhat <- max(rhats$psrf[,1], na.rm = T)

# effectiveSize(out[,params])

```

```{r env waleu}

#NB: PDO/MEI, PDO/NOI, MEI/NOI/NPI, albsa/vwnd, albsa/NPI
#spring: PDO/NOI, PDO/NPI, upwell/NPI, vwnd/albsa, uwnd/NOI, curl/NPGO
#summer: PDO/MEI, PDO/NPGO, AOI/NPI, albsa/chla
#fall: PDO/NOI, PDO/MEI, NOI/MEI, ssh/NPI, temp/so
#winter: PDO/MEI, PDO/NOI, MEI/NPI, vwnd/albsa, albsa/MEI, prod/scalar

# Specify model
SSL_CJS <- nimbleCode({
  
  # Priors and constraints; 
for (i in 1:n_fem) { #females
        for (t in 1:(n_occasions - 1)) {
            logit(phiP[i,t]) <- mu.phi[1] + 
              # b.chlaP*chla[t] +
              b.upP*upwell[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              # b.albsaP*albsa[t] +
              # b.prodP*prod[t] +
              # b.curlP*curl[t] +
              # b.scalP*scal[t] +
              # b.sstP*sst[t] +
              b.AOIP*AOI[t] +
              b.massP*mass_f[i]
            logit(phi1[i,t]) <- mu.phi[2] +             
              # b.chla1*chla[t] +
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              # b.albsa1*albsa[t] +
              # b.prod1*prod[t] +
              # b.curl1*curl[t] +
              # b.scal1*scal[t] +
              # b.sst1*sst[t] +
              b.AOI1*AOI[t] +
              b.mass1*mass_f[i]
            logit(phi2[i,t]) <- mu.phi[3] + 
              # b.chla1*chla[t] +
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              # b.albsa1*albsa[t] +
              # b.prod1*prod[t] +
              # b.curl1*curl[t] +
              # b.scal1*scal[t] +
              # b.sst1*sst[t] +
              b.AOI1*AOI[t] +
              b.mass1*mass_f[i]
            logit(phi3[i,t]) <- mu.phi[4]
            logit(phi4[i,t]) <- mu.phi[5] 
            logit(phi5[i,t]) <- mu.phi[6]
            logit(phiB[i,t]) <- mu.A 
            logit(phiNB[i,t]) <- mu.A 
            logit(delB[i,t]) <- b.delB[resights[i,t]]
            logit(p1[i,t]) <- mean.p1 
            logit(p2[i,t]) <- mean.p2 
            logit(p3[i,t]) <- mean.p3 
            logit(p4[i,t]) <- mean.p4 
            logit(p5[i,t]) <- mean.p5 
            logit(pB[i,t]) <- mean.pA 
            logit(pNB[i,t]) <- mean.pA 
            logit(psi3[i,t]) <- mean.psi3 + b.mass.psi*mass_f[i] 
           logit(psi4[i,t]) <- mean.psi4 + b.mass.psi*mass_f[i] 
            logit(psi5[i,t]) <- mean.psi5 + b.mass.psi*mass_f[i] 
            logit(psiB[i,t]) <- mean.psiB #+ b.mass.psiB*mass_f[i] 
            logit(psiNB[i,t]) <- mean.psiNB #+ b.mass.psiB*mass_f[i]
        }
}
  
  for (t in 4:n_occasions) {
      nat_all[t] <- sum(z[1:n_fem,t] > 6 & z[1:n_fem,t] < 10)/sum(z[1:n_fem,t]>4 & z[1:n_fem,t]<12)
      nat4[t] <- sum(z[1:n_fem,t] == 7)/sum(z[1:n_fem,t] == 7 | z[1:n_fem,t] == 5) #4 yo: 7/(5+7)
      nat5[t] <- sum(z[1:n_fem,t] == 8)/sum(z[1:n_fem,t] == 8 | z[1:n_fem,t] == 6 | z[1:n_fem,t] == 10)
      nat6plus[t] <- sum(z[1:n_fem,t] == 9)/sum(z[1:n_fem,t] == 9 | z[1:n_fem,t] == 11) #6+ yo: 9/(9+11)
  }
  
  for (i in 1:n_m) { #males
        for (t in 1:(n_occasions - 1)) {
            logit(phiPM[i,t]) <- mu.phiM[1] + 
              b.upP*upwell[t] +
              b.vwndP*vwnd[t] +
              b.npgoP*npgo[t] +
              b.AOIP*AOI[t] +
              b.massPM*mass_m[i]
            logit(phi1M[i,t]) <- mu.phiM[2] + 
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.AOI1*AOI[t] +
              b.mass1M*mass_m[i]
            logit(phi2M[i,t]) <- mu.phiM[3] + 
              b.up1*upwell[t] +
              b.vwnd1*vwnd[t] +
              b.npgo1*npgo[t] +
              b.AOI1*AOI[t] +
              b.mass1M*mass_m[i]
            logit(phi3M[i,t]) <- mu.phiM[4] 
            logit(phi4M[i,t]) <- mu.phiM[5] 
            logit(phi5M[i,t]) <- mu.phiM[6] 
            logit(phiBM[i,t]) <- mu.AM 
            logit(p1M[i,t]) <- mean.p1M 
            logit(p2M[i,t]) <- mean.p2M 
            logit(p3M[i,t]) <- mean.p3M 
            logit(p4M[i,t]) <- mean.p4M 
            logit(p5M[i,t]) <- mean.p5M 
            logit(pBM[i,t]) <- mean.pAM
        }
}
  
    #psi
    mean.psi3 <- log(int.psi3/(1 - int.psi3))
    mean.psi4 <- log(int.psi4/(1 - int.psi4))
    mean.psi5 <- log(int.psi5/(1 - int.psi5))
    mean.psiB <- log(int.psiB/(1 - int.psiB))
    mean.psiNB <- log(int.psiNB/(1 - int.psiNB))
    int.psi3 ~ dunif(0,1)
    int.psi4 ~ dunif(0,1)
    int.psi5 ~ dunif(0,1)
    int.psiB ~ dunif(0,1)
    int.psiNB ~ dunif(0,1)
    
    #p
    mean.p1 <- log(int.p1/(1-int.p1))
    int.p1 ~ dunif(0,1)
    mean.p2 <- log(int.p2/(1-int.p2))
    int.p2 ~ dunif(0,1)
    mean.p3 <- log(int.p3/(1-int.p3))
    int.p3 ~ dunif(0,1)
    mean.p4 <- log(int.p4/(1-int.p4))
    int.p4 ~ dunif(0,1)
    mean.p5 <- log(int.p5/(1-int.p5))
    int.p5 ~ dunif(0,1)
    mean.pA <- log(int.pA/(1-int.pA))
    int.pA ~ dunif(0,1)
    
    mean.p1M <- log(int.p1M/(1-int.p1M))
    int.p1M ~ dunif(0,1)
    mean.p2M <- log(int.p2M/(1-int.p2M))
    int.p2M ~ dunif(0,1)
    mean.p3M <- log(int.p3M/(1-int.p3M))
    int.p3M ~ dunif(0,1)
    mean.p4M <- log(int.p4M/(1-int.p4M))
    int.p4M ~ dunif(0,1)
    mean.p5M <- log(int.p5M/(1-int.p5M))
    int.p5M ~ dunif(0,1)
    mean.pAM <- log(int.pAM/(1-int.pAM))
    int.pAM ~ dunif(0,1)

  ## survival
  #females
  mu.phi[1:6] ~ dmnorm(zeros[1:6], P[1:6,1:6])

  for(i in 1:6) zeros[i] <- 0 
  P[1:6,1:6] <- tau.phi*Q[1:6,1:6]
  tau.phi <- 1/(sigma.phi*sigma.phi)
  sigma.phi ~ dexp(rate) # try different rates here 

  #males
  mu.phiM[1:6] ~ dmnorm(zeros.m[1:6], P.m[1:6,1:6])

  for(i in 1:6) zeros.m[i] <- 0 
  P.m[1:6,1:6] <- tau.phiM*Q[1:6,1:6]
  tau.phiM <- 1/(sigma.phiM*sigma.phiM)
  sigma.phiM ~ dexp(rate)
  
    mu.A <- log(int.phiA/(1 - int.phiA))
    mu.AM <- log(int.phiAM/(1 - int.phiAM))
    int.phiA ~ dunif(0,1)
    int.phiAM ~ dunif(0,1)

    p.delB[1] ~ dunif(0,1)
    b.delB[1] <- log(p.delB[1]/(1-p.delB[1]))
    p.delB[2] ~ dunif(0,1)
    b.delB[2] <- log(p.delB[2]/(1-p.delB[2]))
    p.delB[3] ~ dunif(0,1)
    b.delB[3] <- log(p.delB[3]/(1-p.delB[3]))
    b.delB[4] <- -2 #0 on probability scale
    
    #phi mass
    b.massP ~ dnorm(0, sd = s.massP)
    s.massP ~ dexp(rate)
    b.mass1 ~ dnorm(0, sd = s.mass1)
    s.mass1 ~ dexp(rate)
    b.massPM ~ dnorm(0, sd = s.massPM)
    s.massPM ~ dexp(rate)
    b.mass1M ~ dnorm(0, sd = s.mass1M)
    s.mass1M ~ dexp(rate)
    b.mass.psi ~ dnorm(0, sd = s.mass.psi)
    s.mass.psi ~ dexp(rate)
    
    # #env covs - phi

    b.upP ~ dnorm(0, sd = s.upP)
    s.upP ~ dexp(rate)
    b.up1 ~ dnorm(0, sd = s.up1)
    s.up1 ~ dexp(rate)
    
    b.npgoP ~ dnorm(0, sd = s.npgoP)
    s.npgoP ~ dexp(rate)
    b.npgo1 ~ dnorm(0, sd = s.npgo1)
    s.npgo1 ~ dexp(rate)
 
    b.AOIP ~ dnorm(0, pow(s.AOIP,-2))
    s.AOIP ~ dexp(rate)
    b.AOI1 ~ dnorm(0, pow(s.AOI1,-2))
    s.AOI1 ~ dexp(rate)
     
    b.vwndP ~ dnorm(0, pow(s.vwndP,-2))
    s.vwndP ~ dexp(rate)
    b.vwnd1 ~ dnorm(0, pow(s.vwnd1,-2))
    s.vwnd1 ~ dexp(rate)
 
    #likelihood
for (i in 1:n_fem) { #females
    z[i, fc[i]:fc[i]] <- 1 #pups at first capture

for (t in (fc[i] + 1):n_occasions) {
      z[i,t] ~ dcat(state_probs[i,t-1,1:12])
      y[i,t] ~ dcat(event_probs[i,t,1:11])
      
    state_probs[i,t-1,1:12] <- getPHI_f(z = z[i,t-1], 
                                      phiP = phiP[i,t-1], phi1 = phi1[i,t-1], phi2 = phi2[i,t-1], 
                                      phi3 = phi3[i,t-1], phi4 = phi4[i,t-1], phi5 = phi5[i,t-1], 
                                      phiB = phiB[i,t-1], phiNB = phiNB[i,t-1],
                                      psi3 = psi3[i,t-1], psi4 = psi4[i,t-1],
                                      psi5 = psi5[i,t-1], psiB = psiB[i,t-1], psiNB = psiNB[i,t-1])
    
    event_probs[i,t,1:11] <- getP_f(z = z[i,t], 
                                    p1 = p1[i,t-1], p2 = p2[i,t-1], p3 = p3[i,t-1], 
                                    p4 = p4[i,t-1], p5 = p5[i,t-1],
                                    pB = pB[i,t-1], pNB = pNB[i,t-1], delB = delB[i,t-1])
    }
}
   for (i in 1:n_m) { #males
    zm[i, fc_m[i]:fc_m[i]] <- 1
  for (t in (fc_m[i] + 1):n_occasions) {
    zm[i,t] ~ dcat(state_probs_m[i, t-1, 1:8])
    ym[i,t] ~ dcat(event_probs_m[i,t,1:8])
    
    state_probs_m[i,t-1,1:8] <- getPHI_m(z = zm[i,t-1], 
                                      phiPM = phiPM[i,t-1], phi1M = phi1M[i,t-1], phi2M = phi2M[i,t-1], 
                                      phi3M = phi3M[i,t-1], phi4M = phi4M[i,t-1], phi5M = phi5M[i,t-1], 
                                      phiBM = phiBM[i,t-1])
    event_probs_m[i,t,1:8] <- getP_m(z = zm[i,t], 
                                    p1M = p1M[i,t-1], p2M = p2M[i,t-1], p3M = p3M[i,t-1], 
                                    p4M = p4M[i,t-1], p5M = p5M[i,t-1],
                                    pBM = pBM[i,t-1])
    }
   }
    
}) # mod  


#seasonal and rate loops
# for (rate in c(0.25, 0.5, 0.75)) {
for (seas in c('spr', 'sum', 'fall', 'win')) {
  start <- 12; stop <- 18
  
  albsa <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$ALBSA_', seas, '[', start,':', stop,']')))))
  AOI <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$AOI_', seas, '[', start,':', stop,']')))))
  upwell <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$upwell_', seas, '[', start,':', stop,']')))))
  chla <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$chla_', seas, '[', start,':', stop,']')))))
  sst <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$sst_', seas, '[', start,':', stop,']')))))
  vwnd <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$vwnd_', seas, '[', start,':', stop,']')))))
  curl <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$curl_', seas, '[', start,':', stop,']')))))
  prod <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$prod_', seas, '[', start,':', stop,']')))))
  scal <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$scalar_', seas, '[', start,':', stop,']')))))
  npgo <- as.numeric(scale(eval(parse(text = paste0('ocean_SSL$NPGO_', seas, '[', start,':', stop,']')))))

  # fix NA values
  albsa[is.na(albsa)] <- 0
  AOI[is.na(AOI)] <- 0
  upwell[is.na(upwell)] <- 0
  chla[is.na(chla)] <- 0
  sst[is.na(sst)] <- 0
  vwnd[is.na(vwnd)] <- 0
  prod[is.na(prod)] <- 0
  curl[is.na(curl)] <- 0
  scal[is.na(scal)] <- 0
  npgo[is.na(npgo)] <- 0

#data
nim.data <- list(y = y, ym = ym, 
                Q = matrix(c(1,-2,1,0,0,0,
                             -2,5,-4,1,0,0,
                             1,-4,6,-4,1,0,
                             0,1,-4,6,-4,1,
                             0,0,1,-4,5,-2,
                             0,0,0,1,-2,1), ncol = 6, nrow = 6, byrow = T),
                 z = z.st, zm = z.st.m)

nim.constants <- list(n_fem = dim(ch_fem)[1], n_m = dim(ch_m)[1], n_occasions = n_occasions,
                      resights = res_mat, #resights_m = res_mat_m,
                      mass_f = mass_f_waleu, mass_m = mass_m_waleu,
                      # rate = rate,
                      rate = 1,
                      AOI = AOI,
                      vwnd = vwnd,
                      npgo = npgo,
                      upwell = upwell,
                      # albsa = albsa,
                      fc = fc, fc_m = fc_m)

inits <- list(mu.phiM = c(0, 0.5, 1.3, 1.6, 1.5, 2.5),
              # mu.phiM = c(rep(qlogis(0.9), 6)),
              mu.phi = c(1.1, 0.4, 0.4, 1, 1.5, 2.5), #logit scale based on ests
              # mu.phi = c(rep(qlogis(0.9), 6)),
              sigma.phi = 1, sigma.phiM = 1,
              int.phiA = 0.9, int.phiAM = 0.9,
              mean.psi3 = -3.0, mean.psi4 = -1.5, mean.psi5 = -3.5, 
              mean.psiB = -6.0, mean.psiNB = -4.0,
              mean.pAM = -1.5, mean.p5M = -2, mean.p4M = -2.0, mean.p3M = -2, mean.p2M = -1.5,
              mean.pA = 4.0, mean.p5 = -2.5, mean.p4 = -5, mean.p3 = -4.0,
              b.mass.p = 0, b.mass.pm = 0, b.mass = 0, b.mass.m = 0,
              b.mass.psi = 0, #b.mass.psiB = 0,
              b.chlaP = 0, b.chla1 = 0,
              # b.prodP = 0, b.prod1 = 0,
              # b.curlP = 0, b.curl1 = 0,
              # b.scalP = 0, b.scal1 = 0,
              b.npgoP = 0, b.npgo1 = 0,
              # b.albsaP = 0, b.albsa1 = 0,
              # b.sstP = 0, b.sst1 = 0,
              b.upP = 0, b.up1 = 0,
              b.vwndP = 0, b.vwnd1 = 0,
              b.AOIP = 0, b.AOI1 = 0,
              z = z.init, zm = z.init.m)

# params to monitor
params <- c('mean.p1', 'mean.p2', 'mean.p3', 'mean.p4', 'mean.p5', 'mean.pA',
            'int.psi3', 'int.psi4', 'int.psi5', 'int.psiB', 'int.psiNB', 
            'int.p1', 'int.p2', 'int.p3', 'int.p4', 'int.p5',
            'int.pA', 'int.p1M', 'int.p2M', 'int.p3M', 'int.p4M', 'int.p5M', 'int.pAM',
                'mean.p1M', 'mean.p2M', 'mean.p3M', 'mean.p4M', 'mean.p5M', 'mean.pAM',
                "mean.psi3", 'mean.psi4', 'mean.psi5', 'mean.psiB', 'mean.psiNB', 
                'int.phiA', 'int.phiAM', 
                'b.massP', 'b.massPM',  'b.mass1', 'b.mass1M', 'b.mass.psi', #'b.mass.psiB',
                'nat_all', 'nat4', 'nat5', 'nat6plus',
                'mu.A', 'mu.AM',#, #'mu.NBM',
                'mu.phi', 'mu.phiM', 'sigma.phi', 'sigma.phiM',
                'b.vwndP', 'b.vwnd1',
               # 'b.curlP', 'b.curl1',
               # 'b.scalP', 'b.scal1',
               'b.upP', 'b.up1',
                'b.npgoP', 'b.npgo1',
              # 'b.prodP', 'b.prod1',
               'b.AOIP', 'b.AOI1','z', 'zm','b.delB', 'p.delB')

# MCMC settings
n.iter = 30000; n.chains = 3; n.burnin = 18000; nthin = 2; nAdapt = 4
# n.iter = 2000; n.chains = 3; n.burnin = 1000; nthin = 2; nAdapt = 4
# n.iter = 20; n.chains = 2; n.burnin = 8; nthin = 1; nAdapt = 4

# start <- Sys.time()

Rmodel <- nimbleModel(code = SSL_CJS, 
                      constants = nim.constants, data = nim.data, 
                      calculate = F, check = F, inits = inits)

conf <- configureMCMC(Rmodel, monitors = params, control = list(adaptInterval = nAdapt), 
                      thin = nthin, useConjugacy = FALSE)

Rmcmc <- buildMCMC(conf, enableWAIC = TRUE)  #produce uncompiled R mcmc function
# Rmcmc <- buildMCMC(conf)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project = Rmodel)
  
# st2<-Sys.time()
out <- runMCMC(Cmcmc, niter = n.iter, nburnin = n.burnin, nchains = n.chains, inits = inits,
                 setSeed = FALSE, progressBar = TRUE, 
               WAIC = TRUE,
               samplesAsCodaMCMC = TRUE)

# elapsed <- Sys.time()-start

# saveRDS(out, file = here::here('results', paste0('out_full_west_', seas, '.rds')))

} #season
# } #rate

# gelman.diag(out, multivariate=F, autoburnin=F)


```
